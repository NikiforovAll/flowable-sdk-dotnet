//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"

namespace Flowable.Sdk.Bpmn.Models
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IFlowableProcessHttpClient
    {
        /// <summary>Get form data</summary>
        /// <returns>Indicates that form data could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FormDataResponse> GetFormDataAsync(string taskId, string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get form data</summary>
        /// <returns>Indicates that form data could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FormDataResponse> GetFormDataAsync(string taskId, string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Submit task form data</summary>
        /// <returns>Indicates request was successful and the form data was submitted</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> SubmitFormAsync(SubmitFormRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Submit task form data</summary>
        /// <returns>Indicates request was successful and the form data was submitted</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> SubmitFormAsync(SubmitFormRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List historic activity instances</summary>
        /// <param name="activityId">An id of the activity instance.</param>
        /// <param name="activityInstanceId">An id of the historic activity instance.</param>
        /// <param name="activityName">The name of the historic activity instance.</param>
        /// <param name="activityType">The element type of the historic activity instance.</param>
        /// <param name="executionId">The execution id of the historic activity instance.</param>
        /// <param name="finished">Indication if the historic activity instance is finished.</param>
        /// <param name="taskAssignee">The assignee of the historic activity instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic activity instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic activity instance.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic activity instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> ListHistoricActivityInstancesAsync(string activityId, string activityInstanceId, string activityName, string activityType, string executionId, bool? finished, string taskAssignee, string processInstanceId, string processDefinitionId, string tenantId, string tenantIdLike, bool? withoutTenantId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List historic activity instances</summary>
        /// <param name="activityId">An id of the activity instance.</param>
        /// <param name="activityInstanceId">An id of the historic activity instance.</param>
        /// <param name="activityName">The name of the historic activity instance.</param>
        /// <param name="activityType">The element type of the historic activity instance.</param>
        /// <param name="executionId">The execution id of the historic activity instance.</param>
        /// <param name="finished">Indication if the historic activity instance is finished.</param>
        /// <param name="taskAssignee">The assignee of the historic activity instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic activity instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic activity instance.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic activity instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> ListHistoricActivityInstancesAsync(string activityId, string activityInstanceId, string activityName, string activityType, string executionId, bool? finished, string taskAssignee, string processInstanceId, string processDefinitionId, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get historic detail</summary>
        /// <param name="id">The id of the historic detail.</param>
        /// <param name="processInstanceId">The process instance id of the historic detail.</param>
        /// <param name="executionId">The execution id of the historic detail.</param>
        /// <param name="activityInstanceId">The activity instance id of the historic detail.</param>
        /// <param name="taskId">The task id of the historic detail.</param>
        /// <param name="selectOnlyFormProperties">Indication to only return form properties in the result.</param>
        /// <param name="selectOnlyVariableUpdates">Indication to only return variable updates in the result.</param>
        /// <returns>Indicates that historic detail could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> ListHistoricDetailsAsync(string id, string processInstanceId, string executionId, string activityInstanceId, string taskId, bool? selectOnlyFormProperties, bool? selectOnlyVariableUpdates);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get historic detail</summary>
        /// <param name="id">The id of the historic detail.</param>
        /// <param name="processInstanceId">The process instance id of the historic detail.</param>
        /// <param name="executionId">The execution id of the historic detail.</param>
        /// <param name="activityInstanceId">The activity instance id of the historic detail.</param>
        /// <param name="taskId">The task id of the historic detail.</param>
        /// <param name="selectOnlyFormProperties">Indication to only return form properties in the result.</param>
        /// <param name="selectOnlyVariableUpdates">Indication to only return variable updates in the result.</param>
        /// <returns>Indicates that historic detail could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> ListHistoricDetailsAsync(string id, string processInstanceId, string executionId, string activityInstanceId, string taskId, bool? selectOnlyFormProperties, bool? selectOnlyVariableUpdates, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for a historic detail variable</summary>
        /// <returns>Indicates the historic detail instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricDetailVariableDataAsync(string detailId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic detail variable</summary>
        /// <returns>Indicates the historic detail instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricDetailVariableDataAsync(string detailId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of historic process instances</summary>
        /// <param name="processInstanceId">An id of the historic process instance.</param>
        /// <param name="processInstanceName">A name of the historic process instance.</param>
        /// <param name="processInstanceNameLike">A name of the historic process instance used in a like query.</param>
        /// <param name="processInstanceNameLikeIgnoreCase">A name of the historic process instance used in a like query ignoring case.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic process instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic process instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic process instance.</param>
        /// <param name="processDefinitionCategory">The process definition category of the historic process instance.</param>
        /// <param name="processDefinitionVersion">The process definition version of the historic process instance.</param>
        /// <param name="deploymentId">The deployment id of the historic process instance.</param>
        /// <param name="businessKey">The business key of the historic process instance.</param>
        /// <param name="businessKeyLike">Only return instances with a businessKey like this key.</param>
        /// <param name="involvedUser">An involved user of the historic process instance.</param>
        /// <param name="finished">Indication if the historic process instance is finished.</param>
        /// <param name="superProcessInstanceId">An optional parent process id of the historic process instance.</param>
        /// <param name="excludeSubprocesses">Return only historic process instances which are not sub processes.</param>
        /// <param name="finishedAfter">Return only historic process instances that were finished after this date.</param>
        /// <param name="finishedBefore">Return only historic process instances that were finished before this date.</param>
        /// <param name="startedAfter">Return only historic process instances that were started after this date.</param>
        /// <param name="startedBefore">Return only historic process instances that were started before this date.</param>
        /// <param name="startedBy">Return only historic process instances that were started by this user.</param>
        /// <param name="includeProcessVariables">An indication if the historic process instance variables should be returned as well.</param>
        /// <param name="callbackId">Only return instances with the given callbackId.</param>
        /// <param name="callbackType">Only return instances with the given callbackType.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic process instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> ListHistoricProcessInstancesAsync(string processInstanceId, string processInstanceName, string processInstanceNameLike, string processInstanceNameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionName, string processDefinitionCategory, string processDefinitionVersion, string deploymentId, string businessKey, string businessKeyLike, string involvedUser, bool? finished, string superProcessInstanceId, bool? excludeSubprocesses, System.DateTimeOffset? finishedAfter, System.DateTimeOffset? finishedBefore, System.DateTimeOffset? startedAfter, System.DateTimeOffset? startedBefore, string startedBy, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of historic process instances</summary>
        /// <param name="processInstanceId">An id of the historic process instance.</param>
        /// <param name="processInstanceName">A name of the historic process instance.</param>
        /// <param name="processInstanceNameLike">A name of the historic process instance used in a like query.</param>
        /// <param name="processInstanceNameLikeIgnoreCase">A name of the historic process instance used in a like query ignoring case.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic process instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic process instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic process instance.</param>
        /// <param name="processDefinitionCategory">The process definition category of the historic process instance.</param>
        /// <param name="processDefinitionVersion">The process definition version of the historic process instance.</param>
        /// <param name="deploymentId">The deployment id of the historic process instance.</param>
        /// <param name="businessKey">The business key of the historic process instance.</param>
        /// <param name="businessKeyLike">Only return instances with a businessKey like this key.</param>
        /// <param name="involvedUser">An involved user of the historic process instance.</param>
        /// <param name="finished">Indication if the historic process instance is finished.</param>
        /// <param name="superProcessInstanceId">An optional parent process id of the historic process instance.</param>
        /// <param name="excludeSubprocesses">Return only historic process instances which are not sub processes.</param>
        /// <param name="finishedAfter">Return only historic process instances that were finished after this date.</param>
        /// <param name="finishedBefore">Return only historic process instances that were finished before this date.</param>
        /// <param name="startedAfter">Return only historic process instances that were started after this date.</param>
        /// <param name="startedBefore">Return only historic process instances that were started before this date.</param>
        /// <param name="startedBy">Return only historic process instances that were started by this user.</param>
        /// <param name="includeProcessVariables">An indication if the historic process instance variables should be returned as well.</param>
        /// <param name="callbackId">Only return instances with the given callbackId.</param>
        /// <param name="callbackType">Only return instances with the given callbackType.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic process instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> ListHistoricProcessInstancesAsync(string processInstanceId, string processInstanceName, string processInstanceNameLike, string processInstanceNameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionName, string processDefinitionCategory, string processDefinitionVersion, string deploymentId, string businessKey, string businessKeyLike, string involvedUser, bool? finished, string superProcessInstanceId, bool? excludeSubprocesses, System.DateTimeOffset? finishedAfter, System.DateTimeOffset? finishedBefore, System.DateTimeOffset? startedAfter, System.DateTimeOffset? startedBefore, string startedBy, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a historic process instance</summary>
        /// <returns>Indicates that the historic process instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricProcessInstanceResponse> GetHistoricProcessInstanceAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a historic process instance</summary>
        /// <returns>Indicates that the historic process instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricProcessInstanceResponse> GetHistoricProcessInstanceAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a historic process instance</summary>
        /// <returns>Indicates that the historic process instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHistoricProcessInstanceAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a historic process instance</summary>
        /// <returns>Indicates that the historic process instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteHistoricProcessInstanceAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List comments on a historic process instance</summary>
        /// <returns>Indicates the process instance was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListHistoricProcessInstanceCommentsAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List comments on a historic process instance</summary>
        /// <returns>Indicates the process instance was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListHistoricProcessInstanceCommentsAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a new comment on a historic process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> CreateCommentAsync(string processInstanceId, CommentResponse body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new comment on a historic process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> CreateCommentAsync(string processInstanceId, CommentResponse body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> GetCommentAsync(string processInstanceId, string commentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> GetCommentAsync(string processInstanceId, string commentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteCommentAsync(string processInstanceId, string commentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteCommentAsync(string processInstanceId, string commentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List identity links of a historic process instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricProcessInstanceIdentityLinksAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links of a historic process instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricProcessInstanceIdentityLinksAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for a historic process instance variable</summary>
        /// <returns>Indicates the process instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricProcessInstanceVariableDataAsync(string processInstanceId, string variableName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic process instance variable</summary>
        /// <returns>Indicates the process instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricProcessInstanceVariableDataAsync(string processInstanceId, string variableName, System.Threading.CancellationToken cancellationToken);

        /// <summary>List historic task instances</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic task instance.</param>
        /// <param name="processInstanceIdWithChildren">Selects the historic task instances for the process instance and its children.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic task instance.</param>
        /// <param name="processDefinitionKeyLike">The process definition key of the historic task instance, which matches the given value.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic task instance.</param>
        /// <param name="processDefinitionNameLike">The process definition name of the historic task instance, which matches the given value.</param>
        /// <param name="processBusinessKey">The process instance business key of the historic task instance.</param>
        /// <param name="processBusinessKeyLike">The process instance business key of the historic task instance that matches the given value.</param>
        /// <param name="executionId">The execution id of the historic task instance.</param>
        /// <param name="taskDefinitionKey">The task definition key for tasks part of a process</param>
        /// <param name="taskDefinitionKeys">The task definition key for tasks part of a process</param>
        /// <param name="taskName">The task name of the historic task instance.</param>
        /// <param name="taskNameLike">The task name with like operator for the historic task instance.</param>
        /// <param name="taskDescription">The task description of the historic task instance.</param>
        /// <param name="taskDescriptionLike">The task description with like operator for the historic task instance.</param>
        /// <param name="taskCategory">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <param name="taskDeleteReason">The task delete reason of the historic task instance.</param>
        /// <param name="taskDeleteReasonLike">The task delete reason with like operator for the historic task instance.</param>
        /// <param name="taskAssignee">The assignee of the historic task instance.</param>
        /// <param name="taskAssigneeLike">The assignee with like operator for the historic task instance.</param>
        /// <param name="taskOwner">The owner of the historic task instance.</param>
        /// <param name="taskOwnerLike">The owner with like operator for the historic task instance.</param>
        /// <param name="taskInvolvedUser">An involved user of the historic task instance</param>
        /// <param name="taskPriority">The priority of the historic task instance.</param>
        /// <param name="finished">Indication if the historic task instance is finished.</param>
        /// <param name="processFinished">Indication if the process instance of the historic task instance is finished.</param>
        /// <param name="parentTaskId">An optional parent task id of the historic task instance.</param>
        /// <param name="dueDate">Return only historic task instances that have a due date equal this date.</param>
        /// <param name="dueDateAfter">Return only historic task instances that have a due date after this date.</param>
        /// <param name="dueDateBefore">Return only historic task instances that have a due date before this date.</param>
        /// <param name="withoutDueDate">Return only historic task instances that have no due-date. When false is provided as value, this parameter is ignored.</param>
        /// <param name="taskCompletedOn">Return only historic task instances that have been completed on this date.</param>
        /// <param name="taskCompletedAfter">Return only historic task instances that have been completed after this date.</param>
        /// <param name="taskCompletedBefore">Return only historic task instances that have been completed before this date.</param>
        /// <param name="taskCreatedOn">Return only historic task instances that were created on this date.</param>
        /// <param name="taskCreatedBefore">Return only historic task instances that were created before this date.</param>
        /// <param name="taskCreatedAfter">Return only historic task instances that were created after this date.</param>
        /// <param name="includeTaskLocalVariables">An indication if the historic task instance local variables should be returned as well.</param>
        /// <param name="includeProcessVariables">An indication if the historic task instance global variables should be returned as well.</param>
        /// <param name="scopeDefinitionId">Only return historic task instances with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return historic task instances with the given scopeId.</param>
        /// <param name="scopeType">Only return historic task instances with the given scopeType.</param>
        /// <param name="tenantId">Only return historic task instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return historic task instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns historic task instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic task instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> ListHistoricTaskInstancesAsync(string taskId, string processInstanceId, string processInstanceIdWithChildren, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionId, string processDefinitionName, string processDefinitionNameLike, string processBusinessKey, string processBusinessKeyLike, string executionId, string taskDefinitionKey, string taskDefinitionKeys, string taskName, string taskNameLike, string taskDescription, string taskDescriptionLike, string taskCategory, string taskDeleteReason, string taskDeleteReasonLike, string taskAssignee, string taskAssigneeLike, string taskOwner, string taskOwnerLike, string taskInvolvedUser, string taskPriority, bool? finished, bool? processFinished, string parentTaskId, System.DateTimeOffset? dueDate, System.DateTimeOffset? dueDateAfter, System.DateTimeOffset? dueDateBefore, bool? withoutDueDate, System.DateTimeOffset? taskCompletedOn, System.DateTimeOffset? taskCompletedAfter, System.DateTimeOffset? taskCompletedBefore, System.DateTimeOffset? taskCreatedOn, System.DateTimeOffset? taskCreatedBefore, System.DateTimeOffset? taskCreatedAfter, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List historic task instances</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic task instance.</param>
        /// <param name="processInstanceIdWithChildren">Selects the historic task instances for the process instance and its children.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic task instance.</param>
        /// <param name="processDefinitionKeyLike">The process definition key of the historic task instance, which matches the given value.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic task instance.</param>
        /// <param name="processDefinitionNameLike">The process definition name of the historic task instance, which matches the given value.</param>
        /// <param name="processBusinessKey">The process instance business key of the historic task instance.</param>
        /// <param name="processBusinessKeyLike">The process instance business key of the historic task instance that matches the given value.</param>
        /// <param name="executionId">The execution id of the historic task instance.</param>
        /// <param name="taskDefinitionKey">The task definition key for tasks part of a process</param>
        /// <param name="taskDefinitionKeys">The task definition key for tasks part of a process</param>
        /// <param name="taskName">The task name of the historic task instance.</param>
        /// <param name="taskNameLike">The task name with like operator for the historic task instance.</param>
        /// <param name="taskDescription">The task description of the historic task instance.</param>
        /// <param name="taskDescriptionLike">The task description with like operator for the historic task instance.</param>
        /// <param name="taskCategory">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <param name="taskDeleteReason">The task delete reason of the historic task instance.</param>
        /// <param name="taskDeleteReasonLike">The task delete reason with like operator for the historic task instance.</param>
        /// <param name="taskAssignee">The assignee of the historic task instance.</param>
        /// <param name="taskAssigneeLike">The assignee with like operator for the historic task instance.</param>
        /// <param name="taskOwner">The owner of the historic task instance.</param>
        /// <param name="taskOwnerLike">The owner with like operator for the historic task instance.</param>
        /// <param name="taskInvolvedUser">An involved user of the historic task instance</param>
        /// <param name="taskPriority">The priority of the historic task instance.</param>
        /// <param name="finished">Indication if the historic task instance is finished.</param>
        /// <param name="processFinished">Indication if the process instance of the historic task instance is finished.</param>
        /// <param name="parentTaskId">An optional parent task id of the historic task instance.</param>
        /// <param name="dueDate">Return only historic task instances that have a due date equal this date.</param>
        /// <param name="dueDateAfter">Return only historic task instances that have a due date after this date.</param>
        /// <param name="dueDateBefore">Return only historic task instances that have a due date before this date.</param>
        /// <param name="withoutDueDate">Return only historic task instances that have no due-date. When false is provided as value, this parameter is ignored.</param>
        /// <param name="taskCompletedOn">Return only historic task instances that have been completed on this date.</param>
        /// <param name="taskCompletedAfter">Return only historic task instances that have been completed after this date.</param>
        /// <param name="taskCompletedBefore">Return only historic task instances that have been completed before this date.</param>
        /// <param name="taskCreatedOn">Return only historic task instances that were created on this date.</param>
        /// <param name="taskCreatedBefore">Return only historic task instances that were created before this date.</param>
        /// <param name="taskCreatedAfter">Return only historic task instances that were created after this date.</param>
        /// <param name="includeTaskLocalVariables">An indication if the historic task instance local variables should be returned as well.</param>
        /// <param name="includeProcessVariables">An indication if the historic task instance global variables should be returned as well.</param>
        /// <param name="scopeDefinitionId">Only return historic task instances with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return historic task instances with the given scopeId.</param>
        /// <param name="scopeType">Only return historic task instances with the given scopeType.</param>
        /// <param name="tenantId">Only return historic task instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return historic task instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns historic task instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic task instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> ListHistoricTaskInstancesAsync(string taskId, string processInstanceId, string processInstanceIdWithChildren, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionId, string processDefinitionName, string processDefinitionNameLike, string processBusinessKey, string processBusinessKeyLike, string executionId, string taskDefinitionKey, string taskDefinitionKeys, string taskName, string taskNameLike, string taskDescription, string taskDescriptionLike, string taskCategory, string taskDeleteReason, string taskDeleteReasonLike, string taskAssignee, string taskAssigneeLike, string taskOwner, string taskOwnerLike, string taskInvolvedUser, string taskPriority, bool? finished, bool? processFinished, string parentTaskId, System.DateTimeOffset? dueDate, System.DateTimeOffset? dueDateAfter, System.DateTimeOffset? dueDateBefore, bool? withoutDueDate, System.DateTimeOffset? taskCompletedOn, System.DateTimeOffset? taskCompletedAfter, System.DateTimeOffset? taskCompletedBefore, System.DateTimeOffset? taskCreatedOn, System.DateTimeOffset? taskCreatedBefore, System.DateTimeOffset? taskCreatedAfter, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single historic task instance</summary>
        /// <returns>Indicates that the historic task instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricTaskInstanceResponse> GetTaskInstanceAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single historic task instance</summary>
        /// <returns>Indicates that the historic task instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricTaskInstanceResponse> GetTaskInstanceAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a historic task instance</summary>
        /// <returns>Indicates that the historic task instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskInstanceAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a historic task instance</summary>
        /// <returns>Indicates that the historic task instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskInstanceAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a historic task instance form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetHistoricTaskFormAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a historic task instance form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetHistoricTaskFormAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List identity links of a historic task instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricTaskInstanceIdentityLinksAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links of a historic task instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricTaskInstanceIdentityLinksAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the task instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricTaskInstanceVariableDataAsync(string taskId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the task instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricTaskInstanceVariableDataAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>List historic task log entries</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="type">The type of the log entry.</param>
        /// <param name="userId">The user who produced the task change.</param>
        /// <param name="processInstanceId">The process instance id of the historic task log entry.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task log entry.</param>
        /// <param name="scopeId">Only return historic task log entries with the given scopeId.</param>
        /// <param name="scopeDefinitionId">Only return historic task log entries with the given scopeDefinitionId.</param>
        /// <param name="subScopeId">Only return historic task log entries with the given subScopeId</param>
        /// <param name="scopeType">Only return historic task log entries with the given scopeType.</param>
        /// <param name="from">Return task log entries starting from a date.</param>
        /// <param name="to">Return task log entries up to a date.</param>
        /// <param name="tenantId">Only return historic task log entries with the given tenantId.</param>
        /// <param name="fromLogNumber">Return task log entries starting from a log number</param>
        /// <param name="toLogNumber">Return task log entries up to specific a log number</param>
        /// <returns>Indicates that historic task log entries could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricTaskLogEntryResponse> GetHistoricTaskLogEntriesAsync(string taskId, string type, string userId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, string subScopeId, string scopeType, System.DateTimeOffset? from, System.DateTimeOffset? to, string tenantId, string fromLogNumber, string toLogNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List historic task log entries</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="type">The type of the log entry.</param>
        /// <param name="userId">The user who produced the task change.</param>
        /// <param name="processInstanceId">The process instance id of the historic task log entry.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task log entry.</param>
        /// <param name="scopeId">Only return historic task log entries with the given scopeId.</param>
        /// <param name="scopeDefinitionId">Only return historic task log entries with the given scopeDefinitionId.</param>
        /// <param name="subScopeId">Only return historic task log entries with the given subScopeId</param>
        /// <param name="scopeType">Only return historic task log entries with the given scopeType.</param>
        /// <param name="from">Return task log entries starting from a date.</param>
        /// <param name="to">Return task log entries up to a date.</param>
        /// <param name="tenantId">Only return historic task log entries with the given tenantId.</param>
        /// <param name="fromLogNumber">Return task log entries starting from a log number</param>
        /// <param name="toLogNumber">Return task log entries up to specific a log number</param>
        /// <returns>Indicates that historic task log entries could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricTaskLogEntryResponse> GetHistoricTaskLogEntriesAsync(string taskId, string type, string userId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, string subScopeId, string scopeType, System.DateTimeOffset? from, System.DateTimeOffset? to, string tenantId, string fromLogNumber, string toLogNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of historic variable instances</summary>
        /// <param name="processInstanceId">The process instance id of the historic variable instance.</param>
        /// <param name="taskId">The task id of the historic variable instance.</param>
        /// <param name="excludeTaskVariables">Indication to exclude the task variables from the result.</param>
        /// <param name="variableName">The variable name of the historic variable instance.</param>
        /// <param name="variableNameLike">The variable name using the like operator for the historic variable instance.</param>
        /// <returns>Indicates that historic variable instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> ListHistoricVariableInstancesAsync(string processInstanceId, string taskId, bool? excludeTaskVariables, string variableName, string variableNameLike);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of historic variable instances</summary>
        /// <param name="processInstanceId">The process instance id of the historic variable instance.</param>
        /// <param name="taskId">The task id of the historic variable instance.</param>
        /// <param name="excludeTaskVariables">Indication to exclude the task variables from the result.</param>
        /// <param name="variableName">The variable name of the historic variable instance.</param>
        /// <param name="variableNameLike">The variable name using the like operator for the historic variable instance.</param>
        /// <returns>Indicates that historic variable instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> ListHistoricVariableInstancesAsync(string processInstanceId, string taskId, bool? excludeTaskVariables, string variableName, string variableNameLike, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the variable instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricInstanceVariableDataAsync(string varInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the variable instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricInstanceVariableDataAsync(string varInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List groups</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="name">Only return groups with the given name</param>
        /// <param name="type">Only return groups with the given type</param>
        /// <param name="nameLike">Only return groups with a name like the given value. Use % as wildcard-character.</param>
        /// <param name="member">Only return groups which have a member with the given username.</param>
        /// <param name="potentialStarter">Only return groups which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested groups were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseGroupResponse> ListGroupsAsync(string id, string name, string type, string nameLike, string member, string potentialStarter, Sort? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List groups</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="name">Only return groups with the given name</param>
        /// <param name="type">Only return groups with the given type</param>
        /// <param name="nameLike">Only return groups with a name like the given value. Use % as wildcard-character.</param>
        /// <param name="member">Only return groups which have a member with the given username.</param>
        /// <param name="potentialStarter">Only return groups which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested groups were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseGroupResponse> ListGroupsAsync(string id, string name, string type, string nameLike, string member, string potentialStarter, Sort? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GroupResponse> CreateGroupAsync(GroupRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GroupResponse> CreateGroupAsync(GroupRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single group</summary>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GroupResponse> GetGroupAsync(string groupId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single group</summary>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GroupResponse> GetGroupAsync(string groupId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a group</summary>
        /// <returns>Indicates the group was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GroupResponse> UpdateGroupAsync(string groupId, GroupRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a group</summary>
        /// <returns>Indicates the group was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GroupResponse> UpdateGroupAsync(string groupId, GroupRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a group</summary>
        /// <returns>Indicates the group was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteGroupAsync(string groupId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a group</summary>
        /// <returns>Indicates the group was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteGroupAsync(string groupId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Add a member to a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MembershipResponse> CreateMembershipAsync(string groupId, MembershipRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a member to a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MembershipResponse> CreateMembershipAsync(string groupId, MembershipRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a member from a group</summary>
        /// <returns>Indicates the group was found and the member has been deleted. The response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMembershipAsync(string groupId, string userId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a member from a group</summary>
        /// <returns>Indicates the group was found and the member has been deleted. The response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMembershipAsync(string groupId, string userId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List users</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="firstName">Only return users with the given firstname</param>
        /// <param name="lastName">Only return users with the given lastname</param>
        /// <param name="displayName">Only return users with the given displayName</param>
        /// <param name="email">Only return users with the given email</param>
        /// <param name="firstNameLike">Only return userswith a firstname like the given value. Use % as wildcard-character.</param>
        /// <param name="lastNameLike">Only return users with a lastname like the given value. Use % as wildcard-character.</param>
        /// <param name="displayNameLike">Only return users with a displayName like the given value. Use % as wildcard-character.</param>
        /// <param name="emailLike">Only return users with an email like the given value. Use % as wildcard-character.</param>
        /// <param name="memberOfGroup">Only return users which are a member of the given group.</param>
        /// <param name="tenantId">Only return users which are a members of the given tenant.</param>
        /// <param name="potentialStarter">Only return users  which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseUserResponse> ListUsersAsync(string id, string firstName, string lastName, string displayName, string email, string firstNameLike, string lastNameLike, string displayNameLike, string emailLike, string memberOfGroup, string tenantId, string potentialStarter, Sort2? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List users</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="firstName">Only return users with the given firstname</param>
        /// <param name="lastName">Only return users with the given lastname</param>
        /// <param name="displayName">Only return users with the given displayName</param>
        /// <param name="email">Only return users with the given email</param>
        /// <param name="firstNameLike">Only return userswith a firstname like the given value. Use % as wildcard-character.</param>
        /// <param name="lastNameLike">Only return users with a lastname like the given value. Use % as wildcard-character.</param>
        /// <param name="displayNameLike">Only return users with a displayName like the given value. Use % as wildcard-character.</param>
        /// <param name="emailLike">Only return users with an email like the given value. Use % as wildcard-character.</param>
        /// <param name="memberOfGroup">Only return users which are a member of the given group.</param>
        /// <param name="tenantId">Only return users which are a members of the given tenant.</param>
        /// <param name="potentialStarter">Only return users  which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseUserResponse> ListUsersAsync(string id, string firstName, string lastName, string displayName, string email, string firstNameLike, string lastNameLike, string displayNameLike, string emailLike, string memberOfGroup, string tenantId, string potentialStarter, Sort2? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a user</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserResponse> CreateUserAsync(UserRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a user</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserResponse> CreateUserAsync(UserRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single user</summary>
        /// <returns>Indicates the user exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserResponse> GetUserAsync(string userId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single user</summary>
        /// <returns>Indicates the user exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserResponse> GetUserAsync(string userId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a user</summary>
        /// <returns>Indicates the user was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserResponse> UpdateUserAsync(string userId, UserRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a user</summary>
        /// <returns>Indicates the user was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserResponse> UpdateUserAsync(string userId, UserRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a user</summary>
        /// <returns>Indicates the user was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteUserAsync(string userId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a user</summary>
        /// <returns>Indicates the user was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteUserAsync(string userId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List user’s info</summary>
        /// <returns>Indicates the user was found and list of info (key and url) is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserInfoResponse>> ListUserInfoAsync(string userId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List user’s info</summary>
        /// <returns>Indicates the user was found and list of info (key and url) is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserInfoResponse>> ListUserInfoAsync(string userId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a new user’s info entry</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserInfoResponse> CreateUserInfoAsync(string userId, UserInfoRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new user’s info entry</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserInfoResponse> CreateUserInfoAsync(string userId, UserInfoRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a user’s info</summary>
        /// <returns>Indicates the user was found and the user has info for the given key.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserInfoResponse> GetUserInfoAsync(string userId, string key);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a user’s info</summary>
        /// <returns>Indicates the user was found and the user has info for the given key.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserInfoResponse> GetUserInfoAsync(string userId, string key, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a user’s info</summary>
        /// <returns>Indicates the user was found and the info has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserInfoResponse> UpdateUserInfoAsync(string userId, string key, UserInfoRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a user’s info</summary>
        /// <returns>Indicates the user was found and the info has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<UserInfoResponse> UpdateUserInfoAsync(string userId, string key, UserInfoRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a user’s info</summary>
        /// <returns>Indicates the user was found and the info for the given key has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteUserInfoAsync(string userId, string key);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a user’s info</summary>
        /// <returns>Indicates the user was found and the info for the given key has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteUserInfoAsync(string userId, string key, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a user’s picture</summary>
        /// <returns>Indicates the user was found and has a picture, which is returned in the body.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetUserPictureAsync(string userId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a user’s picture</summary>
        /// <returns>Indicates the user was found and has a picture, which is returned in the body.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetUserPictureAsync(string userId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Updating a user’s picture</summary>
        /// <param name="file">Picture to update</param>
        /// <returns>Indicates the user was found and the picture has been updated. The response-body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateUserPictureAsync(string userId, FileParameter file);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Updating a user’s picture</summary>
        /// <param name="file">Picture to update</param>
        /// <returns>Indicates the user was found and the picture has been updated. The response-body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateUserPictureAsync(string userId, FileParameter file, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single batch part</summary>
        /// <returns>Indicates the batch part exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BatchPartResponse> GetBatchPartAsync(string batchPartId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single batch part</summary>
        /// <returns>Indicates the batch part exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BatchPartResponse> GetBatchPartAsync(string batchPartId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the batch part document</summary>
        /// <returns>Indicates the requested batch part was found and the batch part document has been returned. The response contains the raw batch part document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetBatchPartDocumentAsync(string batchPartId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the batch part document</summary>
        /// <returns>Indicates the requested batch part was found and the batch part document has been returned. The response contains the raw batch part document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetBatchPartDocumentAsync(string batchPartId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List batches</summary>
        /// <param name="id">Only return batch with the given id</param>
        /// <param name="batchType">Only return batches for the given type</param>
        /// <param name="searchKey">Only return batches for the given search key</param>
        /// <param name="searchKey2">Only return batches for the given search key2</param>
        /// <param name="createTimeBefore">Only return batches created before the given date</param>
        /// <param name="createTimeAfter">Only batches batches created after the given date</param>
        /// <param name="completeTimeBefore">Only return batches completed before the given date</param>
        /// <param name="completeTimeAfter">Only batches batches completed after the given date</param>
        /// <param name="status">Only return batches for the given status</param>
        /// <param name="tenantId">Only return batches for the given tenant id</param>
        /// <param name="tenantIdLike">Only return batches like given search key</param>
        /// <param name="withoutTenantId">If true, only returns batches without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates the requested batches were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseBatchResponse> ListBatchesAsync(string id, string batchType, string searchKey, string searchKey2, System.DateTimeOffset? createTimeBefore, System.DateTimeOffset? createTimeAfter, System.DateTimeOffset? completeTimeBefore, System.DateTimeOffset? completeTimeAfter, string status, string tenantId, string tenantIdLike, bool? withoutTenantId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List batches</summary>
        /// <param name="id">Only return batch with the given id</param>
        /// <param name="batchType">Only return batches for the given type</param>
        /// <param name="searchKey">Only return batches for the given search key</param>
        /// <param name="searchKey2">Only return batches for the given search key2</param>
        /// <param name="createTimeBefore">Only return batches created before the given date</param>
        /// <param name="createTimeAfter">Only batches batches created after the given date</param>
        /// <param name="completeTimeBefore">Only return batches completed before the given date</param>
        /// <param name="completeTimeAfter">Only batches batches completed after the given date</param>
        /// <param name="status">Only return batches for the given status</param>
        /// <param name="tenantId">Only return batches for the given tenant id</param>
        /// <param name="tenantIdLike">Only return batches like given search key</param>
        /// <param name="withoutTenantId">If true, only returns batches without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates the requested batches were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseBatchResponse> ListBatchesAsync(string id, string batchType, string searchKey, string searchKey2, System.DateTimeOffset? createTimeBefore, System.DateTimeOffset? createTimeAfter, System.DateTimeOffset? completeTimeBefore, System.DateTimeOffset? completeTimeAfter, string status, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single batch</summary>
        /// <returns>Indicates the batch exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BatchResponse> GetBatchAsync(string batchId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single batch</summary>
        /// <returns>Indicates the batch exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BatchResponse> GetBatchAsync(string batchId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a batch</summary>
        /// <returns>Indicates the batch was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBatchAsync(string batchId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a batch</summary>
        /// <returns>Indicates the batch was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBatchAsync(string batchId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the batch document</summary>
        /// <returns>Indicates the requested batch was found and the batch document has been returned. The response contains the raw batch document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetBatchDocumentAsync(string batchId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the batch document</summary>
        /// <returns>Indicates the requested batch was found and the batch document has been returned. The response contains the raw batch document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetBatchDocumentAsync(string batchId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List batch parts</summary>
        /// <param name="status">Only return batch parts for the given status</param>
        /// <returns>Indicates the requested batch parts were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchPartResponse>> ListBatchesPartAsync(string batchId, string status);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List batch parts</summary>
        /// <param name="status">Only return batch parts for the given status</param>
        /// <returns>Indicates the requested batch parts were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchPartResponse>> ListBatchesPartAsync(string batchId, string status, System.Threading.CancellationToken cancellationToken);

        /// <summary>List deadletter jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListDeadLetterJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort3? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List deadletter jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListDeadLetterJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort3? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single deadletter job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetDeadletterJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single deadletter job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetDeadletterJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Move a single deadletter job</summary>
        /// <returns>Indicates the dead letter job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteDeadLetterJobActionAsync(string jobId, RestActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Move a single deadletter job</summary>
        /// <returns>Indicates the dead letter job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteDeadLetterJobActionAsync(string jobId, RestActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a deadletter job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeadLetterJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a deadletter job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeadLetterJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the exception stacktrace for a deadletter job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetDeadLetterJobStacktraceAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a deadletter job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetDeadLetterJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get engine info</summary>
        /// <returns>Indicates the engine info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessEngineInfoResponse> GetEngineInfoAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get engine info</summary>
        /// <returns>Indicates the engine info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessEngineInfoResponse> GetEngineInfoAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>List jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort4? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort4? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single job</summary>
        /// <returns>Indicates the job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single job</summary>
        /// <returns>Indicates the job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Execute a single job</summary>
        /// <returns>Indicates the job was executed. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteJobActionAsync(string jobId, RestActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute a single job</summary>
        /// <returns>Indicates the job was executed. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteJobActionAsync(string jobId, RestActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the exception stacktrace for a job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetJobStacktraceAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List engine properties</summary>
        /// <returns>Indicates the properties are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> GetPropertiesAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List engine properties</summary>
        /// <returns>Indicates the properties are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> GetPropertiesAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>List suspended jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListSuspendedJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort5? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List suspended jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListSuspendedJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort5? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single suspended job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetSuspendedJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single suspended job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetSuspendedJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a suspended job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSuspendedJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a suspended job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteSuspendedJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the exception stacktrace for a suspended job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetSuspendedJobStacktraceAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a suspended job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetSuspendedJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List tables</summary>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TableResponse>> ListTablesAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List tables</summary>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TableResponse>> ListTablesAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single table</summary>
        /// <returns>Indicates the table exists and the table count is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TableResponse> GetTableAsync(string tableName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single table</summary>
        /// <returns>Indicates the table exists and the table count is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TableResponse> GetTableAsync(string tableName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get column info for a single table</summary>
        /// <returns>Indicates the table exists and the table column info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TableMetaData> GetTableMetaDataAsync(string tableName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get column info for a single table</summary>
        /// <returns>Indicates the table exists and the table column info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TableMetaData> GetTableMetaDataAsync(string tableName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get row data for a single table</summary>
        /// <param name="start">Index of the first row to fetch. Defaults to 0.</param>
        /// <param name="size">Number of rows to fetch, starting from start. Defaults to 10.</param>
        /// <param name="orderAscendingColumn">Name of the column to sort the resulting rows on, ascending.</param>
        /// <param name="orderDescendingColumn">Name of the column to sort the resulting rows on, descending.</param>
        /// <returns>Indicates the table exists and the table row data is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseListMapStringObject> GetTableDataAsync(string tableName, int? start, int? size, string orderAscendingColumn, string orderDescendingColumn);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get row data for a single table</summary>
        /// <param name="start">Index of the first row to fetch. Defaults to 0.</param>
        /// <param name="size">Number of rows to fetch, starting from start. Defaults to 10.</param>
        /// <param name="orderAscendingColumn">Name of the column to sort the resulting rows on, ascending.</param>
        /// <param name="orderDescendingColumn">Name of the column to sort the resulting rows on, descending.</param>
        /// <returns>Indicates the table exists and the table row data is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseListMapStringObject> GetTableDataAsync(string tableName, int? start, int? size, string orderAscendingColumn, string orderDescendingColumn, System.Threading.CancellationToken cancellationToken);

        /// <summary>List timer jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListTimerJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort6? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List timer jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseJobResponse> ListTimerJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort6? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single timer job</summary>
        /// <returns>Indicates the timer job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetTimerJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single timer job</summary>
        /// <returns>Indicates the timer job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JobResponse> GetTimerJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Move a single timer job</summary>
        /// <returns>Indicates the timer job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteTimerJobActionAsync(string jobId, RestActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Move a single timer job</summary>
        /// <returns>Indicates the timer job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteTimerJobActionAsync(string jobId, RestActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a timer job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTimerJobAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a timer job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTimerJobAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the exception stacktrace for a timer job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetTimerJobStacktraceAsync(string jobId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a timer job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetTimerJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query executions</summary>
        /// <returns>Indicates request was successful and the executions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseExecutionResponse> QueryExecutionsAsync(ExecutionQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query executions</summary>
        /// <returns>Indicates request was successful and the executions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseExecutionResponse> QueryExecutionsAsync(ExecutionQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query for historic activity instances</summary>
        /// <returns>Indicates request was successful and the activities are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> QueryActivityInstancesAsync(HistoricActivityInstanceQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic activity instances</summary>
        /// <returns>Indicates request was successful and the activities are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> QueryActivityInstancesAsync(HistoricActivityInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query for historic details</summary>
        /// <returns>Indicates request was successful and the historic details are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> QueryHistoricDetailAsync(HistoricDetailQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic details</summary>
        /// <returns>Indicates request was successful and the historic details are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> QueryHistoricDetailAsync(HistoricDetailQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query for historic process instances</summary>
        /// <returns>Indicates request was successful and the process instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> QueryHistoricProcessInstanceAsync(HistoricProcessInstanceQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic process instances</summary>
        /// <returns>Indicates request was successful and the process instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> QueryHistoricProcessInstanceAsync(HistoricProcessInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query for historic task instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> QueryHistoricTaskInstanceAsync(HistoricTaskInstanceQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic task instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> QueryHistoricTaskInstanceAsync(HistoricTaskInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query for historic variable instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> QueryVariableInstancesAsync(HistoricVariableInstanceQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic variable instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> QueryVariableInstancesAsync(HistoricVariableInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query process instances</summary>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> QueryProcessInstancesAsync(ProcessInstanceQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query process instances</summary>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> QueryProcessInstancesAsync(ProcessInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Query for tasks</summary>
        /// <returns>Indicates request was successful and the tasks are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseTaskResponse> QueryTasksAsync(TaskQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for tasks</summary>
        /// <returns>Indicates request was successful and the tasks are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseTaskResponse> QueryTasksAsync(TaskQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List Deployments</summary>
        /// <param name="name">Only return deployments with the given name.</param>
        /// <param name="nameLike">Only return deployments with a name like the given name.</param>
        /// <param name="category">Only return deployments with the given category.</param>
        /// <param name="categoryNotEquals">Only return deployments which do not have the given category.</param>
        /// <param name="parentDeploymentId">Only return deployments with the given parent deployment id.</param>
        /// <param name="parentDeploymentIdLike">Only return deployments with a parent deployment id like the given value.</param>
        /// <param name="tenantId">Only return deployments with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return deployments with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns deployments without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseDeploymentResponse> ListDeploymentsAsync(string name, string nameLike, string category, string categoryNotEquals, string parentDeploymentId, string parentDeploymentIdLike, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort7? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Deployments</summary>
        /// <param name="name">Only return deployments with the given name.</param>
        /// <param name="nameLike">Only return deployments with a name like the given name.</param>
        /// <param name="category">Only return deployments with the given category.</param>
        /// <param name="categoryNotEquals">Only return deployments which do not have the given category.</param>
        /// <param name="parentDeploymentId">Only return deployments with the given parent deployment id.</param>
        /// <param name="parentDeploymentIdLike">Only return deployments with a parent deployment id like the given value.</param>
        /// <param name="tenantId">Only return deployments with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return deployments with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns deployments without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseDeploymentResponse> ListDeploymentsAsync(string name, string nameLike, string category, string categoryNotEquals, string parentDeploymentId, string parentDeploymentIdLike, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort7? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a new deployment</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeploymentResponse> UploadDeploymentAsync(string deploymentKey, string deploymentName, string tenantId, FileParameter file);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new deployment</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeploymentResponse> UploadDeploymentAsync(string deploymentKey, string deploymentName, string tenantId, FileParameter file, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a deployment</summary>
        /// <param name="deploymentId">The id of the deployment to get.</param>
        /// <returns>Indicates the deployment was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeploymentResponse> GetDeploymentAsync(string deploymentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deployment</summary>
        /// <param name="deploymentId">The id of the deployment to get.</param>
        /// <returns>Indicates the deployment was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeploymentResponse> GetDeploymentAsync(string deploymentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a deployment</summary>
        /// <returns>Indicates the deployment was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeploymentAsync(string deploymentId, bool? cascade);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a deployment</summary>
        /// <returns>Indicates the deployment was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteDeploymentAsync(string deploymentId, bool? cascade, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a deployment resource content</summary>
        /// <param name="resourceName">The name of the resource to get. Make sure you URL-encode the resourceName in case it contains forward slashes. Eg: use diagrams%2Fmy-process.bpmn20.xml instead of diagrams/my-process.bpmn20.xml.</param>
        /// <returns>Indicates both deployment and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetDeploymentResourceDataAsync(string deploymentId, string resourceName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deployment resource content</summary>
        /// <param name="resourceName">The name of the resource to get. Make sure you URL-encode the resourceName in case it contains forward slashes. Eg: use diagrams%2Fmy-process.bpmn20.xml instead of diagrams/my-process.bpmn20.xml.</param>
        /// <returns>Indicates both deployment and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetDeploymentResourceDataAsync(string deploymentId, string resourceName, System.Threading.CancellationToken cancellationToken);

        /// <summary>List resources in a deployment</summary>
        /// <returns>Indicates the deployment was found and the resource list has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DeploymentResourceResponse>> ListDeploymentResourcesAsync(string deploymentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List resources in a deployment</summary>
        /// <returns>Indicates the deployment was found and the resource list has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DeploymentResourceResponse>> ListDeploymentResourcesAsync(string deploymentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a deployment resource</summary>
        /// <returns>Indicates both deployment and resource have been found and the resource has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeploymentResourceResponse> GetDeploymentResourceAsync(string deploymentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deployment resource</summary>
        /// <returns>Indicates both deployment and resource have been found and the resource has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeploymentResourceResponse> GetDeploymentResourceAsync(string deploymentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List models</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="category">Only return models with the given category.</param>
        /// <param name="categoryLike">Only return models with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return models which do not have the given category.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models with a name like the given name.</param>
        /// <param name="key">Only return models with the given key.</param>
        /// <param name="deploymentId">Only return models with the given category.</param>
        /// <param name="version">Only return models with the given version.</param>
        /// <param name="latestVersion">If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned.</param>
        /// <param name="deployed">If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null).</param>
        /// <param name="tenantId">Only return models with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return models with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the models are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseModelResponse> ListModelsAsync(string id, string category, string categoryLike, string categoryNotEquals, string name, string nameLike, string key, string deploymentId, int? version, bool? latestVersion, bool? deployed, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort8? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List models</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="category">Only return models with the given category.</param>
        /// <param name="categoryLike">Only return models with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return models which do not have the given category.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models with a name like the given name.</param>
        /// <param name="key">Only return models with the given key.</param>
        /// <param name="deploymentId">Only return models with the given category.</param>
        /// <param name="version">Only return models with the given version.</param>
        /// <param name="latestVersion">If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned.</param>
        /// <param name="deployed">If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null).</param>
        /// <param name="tenantId">Only return models with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return models with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the models are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseModelResponse> ListModelsAsync(string id, string category, string categoryLike, string categoryNotEquals, string name, string nameLike, string key, string deploymentId, int? version, bool? latestVersion, bool? deployed, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort8? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a model</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ModelResponse> CreateModelAsync(ModelRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a model</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ModelResponse> CreateModelAsync(ModelRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a model</summary>
        /// <returns>Indicates the model was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ModelResponse> GetModelAsync(string modelId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a model</summary>
        /// <returns>Indicates the model was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ModelResponse> GetModelAsync(string modelId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a model</summary>
        /// <returns>Indicates the model was found and updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ModelResponse> UpdateModelAsync(string modelId, ModelRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a model</summary>
        /// <returns>Indicates the model was found and updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ModelResponse> UpdateModelAsync(string modelId, ModelRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a model</summary>
        /// <returns>Indicates the model was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteModelAsync(string modelId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a model</summary>
        /// <returns>Indicates the model was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteModelAsync(string modelId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelBytesAsync(string modelId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelBytesAsync(string modelId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Set the editor source for a model</summary>
        /// <returns>Indicates the model was found and the source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetModelSourceAsync(string modelId, FileParameter file);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Set the editor source for a model</summary>
        /// <returns>Indicates the model was found and the source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetModelSourceAsync(string modelId, FileParameter file, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExtraEditorSourceAsync(string modelId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExtraEditorSourceAsync(string modelId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Set the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and the extra source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetExtraEditorSourceAsync(string modelId, FileParameter file);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Set the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and the extra source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SetExtraEditorSourceAsync(string modelId, FileParameter file, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of process definitions</summary>
        /// <param name="version">Only return process definitions with the given version.</param>
        /// <param name="name">Only return process definitions with the given name.</param>
        /// <param name="nameLike">Only return process definitions with a name like the given name.</param>
        /// <param name="key">Only return process definitions with the given key.</param>
        /// <param name="keyLike">Only return process definitions with a name like the given key.</param>
        /// <param name="resourceName">Only return process definitions with the given resource name.</param>
        /// <param name="resourceNameLike">Only return process definitions with a name like the given resource name.</param>
        /// <param name="category">Only return process definitions with the given category.</param>
        /// <param name="categoryLike">Only return process definitions with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return process definitions which do not have the given category.</param>
        /// <param name="deploymentId">Only return process definitions with the given category.</param>
        /// <param name="startableByUser">Only return process definitions which are part of a deployment with the given id.</param>
        /// <param name="latest">Only return the latest process definition versions. Can only be used together with key and keyLike parameters, using any other parameter will result in a 400-response.</param>
        /// <param name="suspended">If true, only returns process definitions which are suspended. If false, only active process definitions (which are not suspended) are returned.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseProcessDefinitionResponse> ListProcessDefinitionsAsync(int? version, string name, string nameLike, string key, string keyLike, string resourceName, string resourceNameLike, string category, string categoryLike, string categoryNotEquals, string deploymentId, string startableByUser, bool? latest, bool? suspended, Sort9? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of process definitions</summary>
        /// <param name="version">Only return process definitions with the given version.</param>
        /// <param name="name">Only return process definitions with the given name.</param>
        /// <param name="nameLike">Only return process definitions with a name like the given name.</param>
        /// <param name="key">Only return process definitions with the given key.</param>
        /// <param name="keyLike">Only return process definitions with a name like the given key.</param>
        /// <param name="resourceName">Only return process definitions with the given resource name.</param>
        /// <param name="resourceNameLike">Only return process definitions with a name like the given resource name.</param>
        /// <param name="category">Only return process definitions with the given category.</param>
        /// <param name="categoryLike">Only return process definitions with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return process definitions which do not have the given category.</param>
        /// <param name="deploymentId">Only return process definitions with the given category.</param>
        /// <param name="startableByUser">Only return process definitions which are part of a deployment with the given id.</param>
        /// <param name="latest">Only return the latest process definition versions. Can only be used together with key and keyLike parameters, using any other parameter will result in a 400-response.</param>
        /// <param name="suspended">If true, only returns process definitions which are suspended. If false, only active process definitions (which are not suspended) are returned.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseProcessDefinitionResponse> ListProcessDefinitionsAsync(int? version, string name, string nameLike, string key, string keyLike, string resourceName, string resourceNameLike, string category, string categoryLike, string categoryNotEquals, string deploymentId, string startableByUser, bool? latest, bool? suspended, Sort9? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a process definition</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessDefinitionResponse> GetProcessDefinitionAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessDefinitionResponse> GetProcessDefinitionAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Execute actions for a process definition</summary>
        /// <returns>Indicates action has been executed for the specified process. (category altered, activate or suspend)</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessDefinitionResponse> ExecuteProcessDefinitionActionAsync(string processDefinitionId, ProcessDefinitionActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute actions for a process definition</summary>
        /// <returns>Indicates action has been executed for the specified process. (category altered, activate or suspend)</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessDefinitionResponse> ExecuteProcessDefinitionActionAsync(string processDefinitionId, ProcessDefinitionActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Batch migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and batch migration was started.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task BatchMigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Batch migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and batch migration was started.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task BatchMigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List decision tables for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the decision tables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DecisionTableResponse>> ListProcessDefinitionDecisionTablesAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List decision tables for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the decision tables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DecisionTableResponse>> ListProcessDefinitionDecisionTablesAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List form definitions for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the form definitions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FormDefinitionResponse>> ListProcessDefinitionFormDefinitionsAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List form definitions for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the form definitions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FormDefinitionResponse>> ListProcessDefinitionFormDefinitionsAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List candidate starters for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessDefinitionIdentityLinksAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List candidate starters for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessDefinitionIdentityLinksAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Add a candidate starter to a process definition</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> CreateIdentityLinkAsync(string processDefinitionId, RestIdentityLink body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a candidate starter to a process definition</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> CreateIdentityLinkAsync(string processDefinitionId, RestIdentityLink body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> GetIdentityLinkAsync(string processDefinitionId, string family, string identityId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> GetIdentityLinkAsync(string processDefinitionId, string family, string identityId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was removed. The response body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteIdentityLinkAsync(string processDefinitionId, string family, string identityId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was removed. The response body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteIdentityLinkAsync(string processDefinitionId, string family, string identityId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a process definition image</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelResourceAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition image</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelResourceAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task MigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task MigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a process definition BPMN model</summary>
        /// <returns>Indicates the process definition was found and the model is returned. The response contains the full process definition model.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BpmnModel> GetBpmnModelResourceAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition BPMN model</summary>
        /// <returns>Indicates the process definition was found and the model is returned. The response contains the full process definition model.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BpmnModel> GetBpmnModelResourceAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a process definition resource content</summary>
        /// <returns>Indicates both process definition and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessDefinitionResourceAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition resource content</summary>
        /// <returns>Indicates both process definition and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessDefinitionResourceAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a process definition start form</summary>
        /// <returns>Indicates request was successful and the process definition form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetProcessDefinitionStartFormAsync(string processDefinitionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition start form</summary>
        /// <returns>Indicates request was successful and the process definition form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetProcessDefinitionStartFormAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of event subscriptions</summary>
        /// <param name="id">Only return event subscriptions with the given id</param>
        /// <param name="eventType">Only return event subscriptions with the given event type</param>
        /// <param name="eventName">Only return event subscriptions with the given event name</param>
        /// <param name="activityId">Only return event subscriptions with the given activity id</param>
        /// <param name="executionId">Only return event subscriptions with the given execution id</param>
        /// <param name="processInstanceId">Only return event subscriptions part of a process with the given id</param>
        /// <param name="processDefinitionId">Only return event subscriptions with the given process definition id</param>
        /// <param name="scopeId">Only return event subscriptions part of a scope with the given id</param>
        /// <param name="scopeDefinitionId">Only return event subscriptions with the given scope definition id</param>
        /// <param name="createdBefore">Only return event subscriptions which are created before the given date.</param>
        /// <param name="createdAfter">Only return event subscriptions which are created after the given date.</param>
        /// <param name="tenantId">Only return event subscriptions with the given tenant id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested event subscriptions were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseEventSubscriptionResponse> ListEventSubscriptionsAsync(string id, string eventType, string eventName, string activityId, string executionId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, string tenantId, Sort10? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of event subscriptions</summary>
        /// <param name="id">Only return event subscriptions with the given id</param>
        /// <param name="eventType">Only return event subscriptions with the given event type</param>
        /// <param name="eventName">Only return event subscriptions with the given event name</param>
        /// <param name="activityId">Only return event subscriptions with the given activity id</param>
        /// <param name="executionId">Only return event subscriptions with the given execution id</param>
        /// <param name="processInstanceId">Only return event subscriptions part of a process with the given id</param>
        /// <param name="processDefinitionId">Only return event subscriptions with the given process definition id</param>
        /// <param name="scopeId">Only return event subscriptions part of a scope with the given id</param>
        /// <param name="scopeDefinitionId">Only return event subscriptions with the given scope definition id</param>
        /// <param name="createdBefore">Only return event subscriptions which are created before the given date.</param>
        /// <param name="createdAfter">Only return event subscriptions which are created after the given date.</param>
        /// <param name="tenantId">Only return event subscriptions with the given tenant id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested event subscriptions were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseEventSubscriptionResponse> ListEventSubscriptionsAsync(string id, string eventType, string eventName, string activityId, string executionId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, string tenantId, Sort10? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single event subscription</summary>
        /// <returns>Indicates the event subscription exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSubscriptionResponse> GetEventSubscriptionAsync(string eventSubscriptionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single event subscription</summary>
        /// <returns>Indicates the event subscription exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSubscriptionResponse> GetEventSubscriptionAsync(string eventSubscriptionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of executions</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="activityId">Only return executions with the given activity id.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processInstanceId">Only return executions which are part of the process instance with the given id.</param>
        /// <param name="messageEventSubscriptionName">Only return executions which are subscribed to a message with the given name.</param>
        /// <param name="signalEventSubscriptionName">Only return executions which are subscribed to a signal with the given name.</param>
        /// <param name="parentId">Only return executions which are a direct child of the given execution.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseExecutionResponse> ListExecutionsAsync(string id, string activityId, string processDefinitionKey, string processDefinitionId, string processInstanceId, string messageEventSubscriptionName, string signalEventSubscriptionName, string parentId, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort11? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of executions</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="activityId">Only return executions with the given activity id.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processInstanceId">Only return executions which are part of the process instance with the given id.</param>
        /// <param name="messageEventSubscriptionName">Only return executions which are subscribed to a message with the given name.</param>
        /// <param name="signalEventSubscriptionName">Only return executions which are subscribed to a signal with the given name.</param>
        /// <param name="parentId">Only return executions which are a direct child of the given execution.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseExecutionResponse> ListExecutionsAsync(string id, string activityId, string processDefinitionKey, string processDefinitionId, string processInstanceId, string messageEventSubscriptionName, string signalEventSubscriptionName, string parentId, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort11? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Signal event received</summary>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteExecutionActionAsync(ExecutionActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Signal event received</summary>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteExecutionActionAsync(ExecutionActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get an execution</summary>
        /// <returns>Indicates the execution was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ExecutionResponse> GetExecutionAsync(string executionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get an execution</summary>
        /// <returns>Indicates the execution was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ExecutionResponse> GetExecutionAsync(string executionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Execute an action on an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ExecutionResponse> PerformExecutionActionAsync(string executionId, ExecutionActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute an action on an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ExecutionResponse> PerformExecutionActionAsync(string executionId, ExecutionActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List active activities in an execution</summary>
        /// <returns>Indicates the execution was found and activities are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ListExecutionActiveActivitiesAsync(string executionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List active activities in an execution</summary>
        /// <returns>Indicates the execution was found and activities are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ListExecutionActiveActivitiesAsync(string executionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Change the state of an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeExecutionActivityStateAsync(string executionId, ExecutionChangeActivityStateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Change the state of an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeExecutionActivityStateAsync(string executionId, ExecutionChangeActivityStateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListExecutionVariablesAsync(string executionId, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListExecutionVariablesAsync(string executionId, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateOrUpdateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateOrUpdateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete all variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables have been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteLocalVariablesAsync(string executionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables have been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteLocalVariablesAsync(string executionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> GetExecutionVariableAsync(string executionId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> GetExecutionVariableAsync(string executionId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a variable on an execution</summary>
        /// <param name="body">Update a variable on an execution</param>
        /// <returns>Indicates both the process instance and variable were found and variable is updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> UpdateExecutionVariableAsync(string executionId, string variableName, ExecutionVariableResource body, FileParameter file, string name, string type, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a variable on an execution</summary>
        /// <param name="body">Update a variable on an execution</param>
        /// <returns>Indicates both the process instance and variable were found and variable is updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> UpdateExecutionVariableAsync(string executionId, string variableName, ExecutionVariableResource body, FileParameter file, string name, string type, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable has been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletedExecutionVariableAsync(string executionId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable has been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeletedExecutionVariableAsync(string executionId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for an execution</summary>
        /// <returns>Indicates the execution was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExecutionVariableDataAsync(string executionId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for an execution</summary>
        /// <returns>Indicates the execution was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExecutionVariableDataAsync(string executionId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>List process instances</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models like the given name.</param>
        /// <param name="nameLikeIgnoreCase">Only return models like the given name ignoring case.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processDefinitionCategory">Only return process instances with the given process definition category.</param>
        /// <param name="processDefinitionVersion">Only return process instances with the given process definition version.</param>
        /// <param name="processDefinitionEngineVersion">Only return process instances with the given process definition engine version.</param>
        /// <param name="businessKey">Only return process instances with the given businessKey.</param>
        /// <param name="businessKeyLike">Only return process instances with the businessKey like the given key.</param>
        /// <param name="startedBy">Only return process instances started by the given user.</param>
        /// <param name="startedBefore">Only return process instances started before the given date.</param>
        /// <param name="startedAfter">Only return process instances started after the given date.</param>
        /// <param name="involvedUser">Only return process instances in which the given user is involved.</param>
        /// <param name="suspended">If true, only return process instance which are suspended. If false, only return process instances which are not suspended (active).</param>
        /// <param name="superProcessInstanceId">Only return process instances which have the given super process-instance id (for processes that have a call-activities).</param>
        /// <param name="subProcessInstanceId">Only return process instances which have the given sub process-instance id (for processes started as a call-activity).</param>
        /// <param name="excludeSubprocesses">Return only process instances which are not sub processes.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="callbackId">Only return process instances with the given callbackId.</param>
        /// <param name="callbackType">Only return process instances with the given callbackType.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> ListProcessInstancesAsync(string id, string name, string nameLike, string nameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionCategory, int? processDefinitionVersion, string processDefinitionEngineVersion, string businessKey, string businessKeyLike, string startedBy, System.DateTimeOffset? startedBefore, System.DateTimeOffset? startedAfter, string involvedUser, bool? suspended, string superProcessInstanceId, string subProcessInstanceId, bool? excludeSubprocesses, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort12? sort);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List process instances</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models like the given name.</param>
        /// <param name="nameLikeIgnoreCase">Only return models like the given name ignoring case.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processDefinitionCategory">Only return process instances with the given process definition category.</param>
        /// <param name="processDefinitionVersion">Only return process instances with the given process definition version.</param>
        /// <param name="processDefinitionEngineVersion">Only return process instances with the given process definition engine version.</param>
        /// <param name="businessKey">Only return process instances with the given businessKey.</param>
        /// <param name="businessKeyLike">Only return process instances with the businessKey like the given key.</param>
        /// <param name="startedBy">Only return process instances started by the given user.</param>
        /// <param name="startedBefore">Only return process instances started before the given date.</param>
        /// <param name="startedAfter">Only return process instances started after the given date.</param>
        /// <param name="involvedUser">Only return process instances in which the given user is involved.</param>
        /// <param name="suspended">If true, only return process instance which are suspended. If false, only return process instances which are not suspended (active).</param>
        /// <param name="superProcessInstanceId">Only return process instances which have the given super process-instance id (for processes that have a call-activities).</param>
        /// <param name="subProcessInstanceId">Only return process instances which have the given sub process-instance id (for processes started as a call-activity).</param>
        /// <param name="excludeSubprocesses">Return only process instances which are not sub processes.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="callbackId">Only return process instances with the given callbackId.</param>
        /// <param name="callbackType">Only return process instances with the given callbackType.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> ListProcessInstancesAsync(string id, string name, string nameLike, string nameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionCategory, int? processDefinitionVersion, string processDefinitionEngineVersion, string businessKey, string businessKeyLike, string startedBy, System.DateTimeOffset? startedBefore, System.DateTimeOffset? startedAfter, string involvedUser, bool? suspended, string superProcessInstanceId, string subProcessInstanceId, bool? excludeSubprocesses, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort12? sort, System.Threading.CancellationToken cancellationToken);

        /// <summary>Start a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> CreateProcessInstanceAsync(ProcessInstanceCreateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Start a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> CreateProcessInstanceAsync(ProcessInstanceCreateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a process instance</summary>
        /// <returns>Indicates the process instance was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> GetProcessInstanceAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process instance</summary>
        /// <returns>Indicates the process instance was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> GetProcessInstanceAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Activate or suspend a process instance</summary>
        /// <returns>Indicates the process instance was found and action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> PerformProcessInstanceActionAsync(string processInstanceId, ProcessInstanceActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Activate or suspend a process instance</summary>
        /// <returns>Indicates the process instance was found and action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProcessInstanceResponse> PerformProcessInstanceActionAsync(string processInstanceId, ProcessInstanceActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a process instance</summary>
        /// <returns>Indicates the process instance was found and deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessInstanceAsync(string processInstanceId, string deleteReason);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a process instance</summary>
        /// <returns>Indicates the process instance was found and deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessInstanceAsync(string processInstanceId, string deleteReason, System.Threading.CancellationToken cancellationToken);

        /// <summary>Change the state a process instance</summary>
        /// <returns>Indicates the process instance was found and change state activity was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeActivityStateAsync(string processInstanceId, ExecutionChangeActivityStateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Change the state a process instance</summary>
        /// <returns>Indicates the process instance was found and change state activity was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeActivityStateAsync(string processInstanceId, ExecutionChangeActivityStateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get diagram for a process instance</summary>
        /// <returns>Indicates the process instance was found and the diagram was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceDiagramAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get diagram for a process instance</summary>
        /// <returns>Indicates the process instance was found and the diagram was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceDiagramAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Evaluate the conditions of a process instance</summary>
        /// <returns>Indicates the process instance was found and the evaluation of the conditions was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task EvaluateConditionsAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Evaluate the conditions of a process instance</summary>
        /// <returns>Indicates the process instance was found and the evaluation of the conditions was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task EvaluateConditionsAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get involved people for process instance</summary>
        /// <returns>Indicates the process instance was found and links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessInstanceIdentityLinksAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get involved people for process instance</summary>
        /// <returns>Indicates the process instance was found and links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessInstanceIdentityLinksAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Add an involved user to a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> CreateProcessInstanceIdentityLinksAsync(string processInstanceId, RestIdentityLink body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add an involved user to a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> CreateProcessInstanceIdentityLinksAsync(string processInstanceId, RestIdentityLink body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a specific involved people from process instance</summary>
        /// <returns>Indicates the process instance was found and the specified link is retrieved.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> GetProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a specific involved people from process instance</summary>
        /// <returns>Indicates the process instance was found and the specified link is retrieved.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> GetProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Remove an involved user to from process instance</summary>
        /// <returns>Indicates the process instance was found and the link has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Remove an involved user to from process instance</summary>
        /// <returns>Indicates the process instance was found and the link has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Inject activity in a process instance</summary>
        /// <returns>Indicates the process instance was updated and the activity injection was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task InjectActivityInProcessInstanceAsync(string processInstanceId, InjectActivityRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Inject activity in a process instance</summary>
        /// <returns>Indicates the process instance was updated and the activity injection was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task InjectActivityInProcessInstanceAsync(string processInstanceId, InjectActivityRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Migrate process instance</summary>
        /// <returns>Indicates the process instance was found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task MigrateProcessInstanceAsync(string processInstanceId, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Migrate process instance</summary>
        /// <returns>Indicates the process instance was found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task MigrateProcessInstanceAsync(string processInstanceId, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List variables for a process instance</summary>
        /// <returns>Indicates the process instance was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListProcessInstanceVariablesAsync(string processInstanceId, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List variables for a process instance</summary>
        /// <returns>Indicates the process instance was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListProcessInstanceVariablesAsync(string processInstanceId, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create variables or new binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateProcessInstanceVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create variables or new binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateProcessInstanceVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a multiple/single (non)binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateOrUpdateProcessVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a multiple/single (non)binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateOrUpdateProcessVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete all variables</summary>
        /// <returns>Indicates variables were found and have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteLocalProcessVariableAsync(string processInstanceId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all variables</summary>
        /// <returns>Indicates variables were found and have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteLocalProcessVariableAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a variable for a process instance</summary>
        /// <returns>Indicates both the process instance and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> GetProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a variable for a process instance</summary>
        /// <returns>Indicates both the process instance and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> GetProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a single variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> UpdateProcessInstanceVariableAsync(string processInstanceId, string variableName, ProcessInstanceVariableResource body, FileParameter file, string name, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a single variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> UpdateProcessInstanceVariableAsync(string processInstanceId, string variableName, ProcessInstanceVariableResource body, FileParameter file, string name, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a variable</summary>
        /// <returns>Indicates the variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a variable</summary>
        /// <returns>Indicates the variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for a variable</summary>
        /// <returns>Indicates the process instance was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceVariableDataAsync(string processInstanceId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a variable</summary>
        /// <returns>Indicates the process instance was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceVariableDataAsync(string processInstanceId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Signal event received</summary>
        /// <returns>Indicated signal processing is queued as a job, ready to be executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SignalEventReceivedAsync(SignalEventReceivedRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Signal event received</summary>
        /// <returns>Indicated signal processing is queued as a job, ready to be executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SignalEventReceivedAsync(SignalEventReceivedRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of tasks</summary>
        /// <param name="name">Only return models with the given version.</param>
        /// <param name="nameLike">Only return tasks with a name like the given name.</param>
        /// <param name="description">Only return tasks with the given description.</param>
        /// <param name="priority">Only return tasks with the given priority.</param>
        /// <param name="minimumPriority">Only return tasks with a priority greater than the given value.</param>
        /// <param name="maximumPriority">Only return tasks with a priority lower than the given value.</param>
        /// <param name="assignee">Only return tasks assigned to the given user.</param>
        /// <param name="assigneeLike">Only return tasks assigned with an assignee like the given value.</param>
        /// <param name="owner">Only return tasks owned by the given user.</param>
        /// <param name="ownerLike">Only return tasks assigned with an owner like the given value.</param>
        /// <param name="unassigned">Only return tasks that are not assigned to anyone. If false is passed, the value is ignored.</param>
        /// <param name="delegationState">Only return tasks that have the given delegation state. Possible values are pending and resolved.</param>
        /// <param name="candidateUser">Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of.</param>
        /// <param name="candidateGroup">Only return tasks that can be claimed by a user in the given group.</param>
        /// <param name="candidateGroups">Only return tasks that can be claimed by a user in the given groups. Values split by comma.</param>
        /// <param name="involvedUser">Only return tasks in which the given user is involved.</param>
        /// <param name="taskDefinitionKey">Only return tasks with the given task definition id.</param>
        /// <param name="taskDefinitionKeyLike">Only return tasks with a given task definition id like the given value.</param>
        /// <param name="taskDefinitionKeys">Only return tasks with the given task definition ids.</param>
        /// <param name="processInstanceId">Only return tasks which are part of the process instance with the given id.</param>
        /// <param name="processInstanceIdWithChildren">Only return tasks which are part of the process instance and its children with the given id.</param>
        /// <param name="processInstanceBusinessKey">Only return tasks which are part of the process instance with the given business key.</param>
        /// <param name="processInstanceBusinessKeyLike">Only return tasks which are part of the process instance which has a business key like the given value.</param>
        /// <param name="processDefinitionId">Only return tasks which are part of a process instance which has a process definition with the given id.</param>
        /// <param name="processDefinitionKey">Only return tasks which are part of a process instance which has a process definition with the given key.</param>
        /// <param name="processDefinitionKeyLike">Only return tasks which are part of a process instance which has a process definition with a key like the given value.</param>
        /// <param name="processDefinitionName">Only return tasks which are part of a process instance which has a process definition with the given name.</param>
        /// <param name="processDefinitionNameLike">Only return tasks which are part of a process instance which has a process definition with a name like the given value.</param>
        /// <param name="executionId">Only return tasks which are part of the execution with the given id.</param>
        /// <param name="createdOn">Only return tasks which are created on the given date.</param>
        /// <param name="createdBefore">Only return tasks which are created before the given date.</param>
        /// <param name="createdAfter">Only return tasks which are created after the given date.</param>
        /// <param name="dueOn">Only return tasks which are due on the given date.</param>
        /// <param name="dueBefore">Only return tasks which are due before the given date.</param>
        /// <param name="dueAfter">Only return tasks which are due after the given date.</param>
        /// <param name="withoutDueDate">Only return tasks which do not have a due date. The property is ignored if the value is false.</param>
        /// <param name="excludeSubTasks">Only return tasks that are not a subtask of another task.</param>
        /// <param name="active">If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned.</param>
        /// <param name="includeTaskLocalVariables">Indication to include task local variables in the result.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="scopeDefinitionId">Only return tasks with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return tasks with the given scopeId.</param>
        /// <param name="scopeType">Only return tasks with the given scopeType.</param>
        /// <param name="tenantId">Only return tasks with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return tasks with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="candidateOrAssigned">Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups).</param>
        /// <param name="category">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseTaskResponse> ListTasksAsync(string name, string nameLike, string description, string priority, string minimumPriority, string maximumPriority, string assignee, string assigneeLike, string owner, string ownerLike, string unassigned, string delegationState, string candidateUser, string candidateGroup, string candidateGroups, string involvedUser, string taskDefinitionKey, string taskDefinitionKeyLike, string taskDefinitionKeys, string processInstanceId, string processInstanceIdWithChildren, string processInstanceBusinessKey, string processInstanceBusinessKeyLike, string processDefinitionId, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionName, string processDefinitionNameLike, string executionId, System.DateTimeOffset? createdOn, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, System.DateTimeOffset? dueOn, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, bool? withoutDueDate, bool? excludeSubTasks, bool? active, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId, string candidateOrAssigned, string category);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of tasks</summary>
        /// <param name="name">Only return models with the given version.</param>
        /// <param name="nameLike">Only return tasks with a name like the given name.</param>
        /// <param name="description">Only return tasks with the given description.</param>
        /// <param name="priority">Only return tasks with the given priority.</param>
        /// <param name="minimumPriority">Only return tasks with a priority greater than the given value.</param>
        /// <param name="maximumPriority">Only return tasks with a priority lower than the given value.</param>
        /// <param name="assignee">Only return tasks assigned to the given user.</param>
        /// <param name="assigneeLike">Only return tasks assigned with an assignee like the given value.</param>
        /// <param name="owner">Only return tasks owned by the given user.</param>
        /// <param name="ownerLike">Only return tasks assigned with an owner like the given value.</param>
        /// <param name="unassigned">Only return tasks that are not assigned to anyone. If false is passed, the value is ignored.</param>
        /// <param name="delegationState">Only return tasks that have the given delegation state. Possible values are pending and resolved.</param>
        /// <param name="candidateUser">Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of.</param>
        /// <param name="candidateGroup">Only return tasks that can be claimed by a user in the given group.</param>
        /// <param name="candidateGroups">Only return tasks that can be claimed by a user in the given groups. Values split by comma.</param>
        /// <param name="involvedUser">Only return tasks in which the given user is involved.</param>
        /// <param name="taskDefinitionKey">Only return tasks with the given task definition id.</param>
        /// <param name="taskDefinitionKeyLike">Only return tasks with a given task definition id like the given value.</param>
        /// <param name="taskDefinitionKeys">Only return tasks with the given task definition ids.</param>
        /// <param name="processInstanceId">Only return tasks which are part of the process instance with the given id.</param>
        /// <param name="processInstanceIdWithChildren">Only return tasks which are part of the process instance and its children with the given id.</param>
        /// <param name="processInstanceBusinessKey">Only return tasks which are part of the process instance with the given business key.</param>
        /// <param name="processInstanceBusinessKeyLike">Only return tasks which are part of the process instance which has a business key like the given value.</param>
        /// <param name="processDefinitionId">Only return tasks which are part of a process instance which has a process definition with the given id.</param>
        /// <param name="processDefinitionKey">Only return tasks which are part of a process instance which has a process definition with the given key.</param>
        /// <param name="processDefinitionKeyLike">Only return tasks which are part of a process instance which has a process definition with a key like the given value.</param>
        /// <param name="processDefinitionName">Only return tasks which are part of a process instance which has a process definition with the given name.</param>
        /// <param name="processDefinitionNameLike">Only return tasks which are part of a process instance which has a process definition with a name like the given value.</param>
        /// <param name="executionId">Only return tasks which are part of the execution with the given id.</param>
        /// <param name="createdOn">Only return tasks which are created on the given date.</param>
        /// <param name="createdBefore">Only return tasks which are created before the given date.</param>
        /// <param name="createdAfter">Only return tasks which are created after the given date.</param>
        /// <param name="dueOn">Only return tasks which are due on the given date.</param>
        /// <param name="dueBefore">Only return tasks which are due before the given date.</param>
        /// <param name="dueAfter">Only return tasks which are due after the given date.</param>
        /// <param name="withoutDueDate">Only return tasks which do not have a due date. The property is ignored if the value is false.</param>
        /// <param name="excludeSubTasks">Only return tasks that are not a subtask of another task.</param>
        /// <param name="active">If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned.</param>
        /// <param name="includeTaskLocalVariables">Indication to include task local variables in the result.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="scopeDefinitionId">Only return tasks with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return tasks with the given scopeId.</param>
        /// <param name="scopeType">Only return tasks with the given scopeType.</param>
        /// <param name="tenantId">Only return tasks with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return tasks with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="candidateOrAssigned">Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups).</param>
        /// <param name="category">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DataResponseTaskResponse> ListTasksAsync(string name, string nameLike, string description, string priority, string minimumPriority, string maximumPriority, string assignee, string assigneeLike, string owner, string ownerLike, string unassigned, string delegationState, string candidateUser, string candidateGroup, string candidateGroups, string involvedUser, string taskDefinitionKey, string taskDefinitionKeyLike, string taskDefinitionKeys, string processInstanceId, string processInstanceIdWithChildren, string processInstanceBusinessKey, string processInstanceBusinessKeyLike, string processDefinitionId, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionName, string processDefinitionNameLike, string executionId, System.DateTimeOffset? createdOn, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, System.DateTimeOffset? dueOn, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, bool? withoutDueDate, bool? excludeSubTasks, bool? active, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId, string candidateOrAssigned, string category, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create Task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TaskResponse> CreateTaskAsync(TaskRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TaskResponse> CreateTaskAsync(TaskRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a task</summary>
        /// <returns>Indicates the task was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TaskResponse> GetTaskAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a task</summary>
        /// <returns>Indicates the task was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TaskResponse> GetTaskAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Tasks actions</summary>
        /// <returns>Indicates the action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteTaskActionAsync(string taskId, TaskActionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Tasks actions</summary>
        /// <returns>Indicates the action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ExecuteTaskActionAsync(string taskId, TaskActionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update a task</summary>
        /// <returns>Indicates the task was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TaskResponse> UpdateTaskAsync(string taskId, TaskRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a task</summary>
        /// <returns>Indicates the task was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TaskResponse> UpdateTaskAsync(string taskId, TaskRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a task</summary>
        /// <param name="cascadeHistory">Whether or not to delete the HistoricTask instance when deleting the task (if applicable). If not provided, this value defaults to false.</param>
        /// <param name="deleteReason">Reason why the task is deleted. This value is ignored when cascadeHistory is true.</param>
        /// <returns>Indicates the task was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskAsync(string taskId, string cascadeHistory, string deleteReason);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a task</summary>
        /// <param name="cascadeHistory">Whether or not to delete the HistoricTask instance when deleting the task (if applicable). If not provided, this value defaults to false.</param>
        /// <param name="deleteReason">Reason why the task is deleted. This value is ignored when cascadeHistory is true.</param>
        /// <returns>Indicates the task was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskAsync(string taskId, string cascadeHistory, string deleteReason, System.Threading.CancellationToken cancellationToken);

        /// <summary>List attachments on a task</summary>
        /// <returns>Indicates the task was found and the attachments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AttachmentResponse>> ListTaskAttachmentsAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List attachments on a task</summary>
        /// <returns>Indicates the task was found and the attachments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AttachmentResponse>> ListTaskAttachmentsAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a new attachment on a task, containing a link to an external resource or an attached file</summary>
        /// <param name="body">create an attachment containing a link to an external resource</param>
        /// <param name="file">Attachment file</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="description">Description of the attachment, optional</param>
        /// <param name="type">Type of attachment, optional. Supports any arbitrary string or a valid HTTP content-type.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AttachmentResponse> CreateAttachmentAsync(string taskId, TaskAttachmentCollectionResource body, FileParameter file, string name, string description, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new attachment on a task, containing a link to an external resource or an attached file</summary>
        /// <param name="body">create an attachment containing a link to an external resource</param>
        /// <param name="file">Attachment file</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="description">Description of the attachment, optional</param>
        /// <param name="type">Type of attachment, optional. Supports any arbitrary string or a valid HTTP content-type.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AttachmentResponse> CreateAttachmentAsync(string taskId, TaskAttachmentCollectionResource body, FileParameter file, string name, string description, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AttachmentResponse> GetAttachmentAsync(string taskId, string attachmentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AttachmentResponse> GetAttachmentAsync(string taskId, string attachmentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteAttachmentAsync(string taskId, string attachmentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteAttachmentAsync(string taskId, string attachmentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the content for an attachment</summary>
        /// <returns>Indicates the task and attachment was found and the requested content is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetAttachmentContentAsync(string taskId, string attachmentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the content for an attachment</summary>
        /// <returns>Indicates the task and attachment was found and the requested content is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetAttachmentContentAsync(string taskId, string attachmentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List comments on a task</summary>
        /// <returns>Indicates the task was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListTaskCommentsAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List comments on a task</summary>
        /// <returns>Indicates the task was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListTaskCommentsAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create a new comment on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> CreateTaskCommentsAsync(string taskId, CommentRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new comment on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> CreateTaskCommentsAsync(string taskId, CommentRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> GetTaskCommentAsync(string taskId, string commentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CommentResponse> GetTaskCommentAsync(string taskId, string commentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskCommentAsync(string taskId, string commentId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskCommentAsync(string taskId, string commentId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List events for a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<EventResponse>> ListTaskEventsAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List events for a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<EventResponse>> ListTaskEventsAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get an event on a task</summary>
        /// <returns>Indicates the task and event were found and the event is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventResponse> GetEventAsync(string taskId, string eventId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get an event on a task</summary>
        /// <returns>Indicates the task and event were found and the event is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventResponse> GetEventAsync(string taskId, string eventId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete an event on a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteEventAsync(string taskId, string eventId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete an event on a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteEventAsync(string taskId, string eventId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a task form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetTaskFormAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a task form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> GetTaskFormAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List identity links for a task</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListTasksInstanceIdentityLinksAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links for a task</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListTasksInstanceIdentityLinksAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create an identity link on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> CreateTaskInstanceIdentityLinksAsync(string taskId, RestIdentityLink body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create an identity link on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> CreateTaskInstanceIdentityLinksAsync(string taskId, RestIdentityLink body, System.Threading.CancellationToken cancellationToken);

        /// <summary>List identity links for a task for either groups or users</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListIdentityLinksForFamilyAsync(string taskId, string family);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links for a task for either groups or users</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListIdentityLinksForFamilyAsync(string taskId, string family, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a single identity link on a task</summary>
        /// <returns>Indicates the task and identity link was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> GetTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single identity link on a task</summary>
        /// <returns>Indicates the task and identity link was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestIdentityLink> GetTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete an identity link on a task</summary>
        /// <returns>Indicates the task and identity link were found and the link has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete an identity link on a task</summary>
        /// <returns>Indicates the task and identity link were found and the link has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type, System.Threading.CancellationToken cancellationToken);

        /// <summary>List of sub tasks for a task</summary>
        /// <returns>Indicates request was successful and the  sub tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TaskResponse>> ListTaskSubtasksAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of sub tasks for a task</summary>
        /// <returns>Indicates request was successful and the  sub tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TaskResponse>> ListTaskSubtasksAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>List variables for a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListTaskVariablesAsync(string taskId, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List variables for a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListTaskVariablesAsync(string taskId, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Create new variables on a task</summary>
        /// <param name="body">Create a variable on a task</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is created. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable that is created. If omitted, local is assumed.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateTaskVariableAsync(string taskId, TaskVariableCollectionResource body, string name, string type, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create new variables on a task</summary>
        /// <param name="body">Create a variable on a task</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is created. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable that is created. If omitted, local is assumed.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> CreateTaskVariableAsync(string taskId, TaskVariableCollectionResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete all local variables on a task</summary>
        /// <returns>Indicates all local task variables have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteAllLocalTaskVariablesAsync(string taskId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all local variables on a task</summary>
        /// <returns>Indicates all local task variables have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteAllLocalTaskVariablesAsync(string taskId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get a variable from a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> GetTaskInstanceVariableAsync(string taskId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a variable from a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> GetTaskInstanceVariableAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Update an existing variable on a task</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>Indicates the variables was updated and the result is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> UpdateTaskInstanceVariableAsync(string taskId, string variableName, TaskVariableResource body, string name, string type, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update an existing variable on a task</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>Indicates the variables was updated and the result is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestVariable> UpdateTaskInstanceVariableAsync(string taskId, string variableName, TaskVariableResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a variable on a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskInstanceVariableAsync(string taskId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a variable on a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteTaskInstanceVariableAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

        /// <summary>Get the binary data for a variable</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetTaskVariableDataAsync(string taskId, string variableName, string scope);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a variable</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetTaskVariableDataAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Artifact
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Artifact FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Artifact>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AttachmentResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Can be any arbitrary value. When a valid formatted media-type (e.g. application/xml, text/plain) is included, the binary content HTTP response content-type will be set the given value.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("taskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        /// <summary>contentUrl:In case the attachment is a link to an external resource, the externalUrl contains the URL to the external content. If the attachment content is present in the Flowable engine, the contentUrl will contain an URL where the binary content can be streamed from.</summary>
        [Newtonsoft.Json.JsonProperty("externalUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("contentUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static AttachmentResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AttachmentResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BaseElement
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static BaseElement FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BaseElement>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BatchPartResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("batchId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchId { get; set; }

        [Newtonsoft.Json.JsonProperty("batchUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("batchType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchType { get; set; }

        [Newtonsoft.Json.JsonProperty("searchKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchKey { get; set; }

        [Newtonsoft.Json.JsonProperty("searchKey2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchKey2 { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("subScopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("createTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreateTime { get; set; }

        [Newtonsoft.Json.JsonProperty("completeTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CompleteTime { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static BatchPartResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BatchPartResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BatchResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("batchType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchType { get; set; }

        [Newtonsoft.Json.JsonProperty("searchKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchKey { get; set; }

        [Newtonsoft.Json.JsonProperty("searchKey2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchKey2 { get; set; }

        [Newtonsoft.Json.JsonProperty("createTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreateTime { get; set; }

        [Newtonsoft.Json.JsonProperty("completeTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CompleteTime { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static BatchResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BatchResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BpmnModel
    {
        [Newtonsoft.Json.JsonProperty("definitionsAttributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> DefinitionsAttributes { get; set; }

        [Newtonsoft.Json.JsonProperty("processes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Process> Processes { get; set; }

        [Newtonsoft.Json.JsonProperty("locationMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, GraphicInfo> LocationMap { get; set; }

        [Newtonsoft.Json.JsonProperty("labelLocationMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, GraphicInfo> LabelLocationMap { get; set; }

        [Newtonsoft.Json.JsonProperty("flowLocationMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<GraphicInfo>> FlowLocationMap { get; set; }

        [Newtonsoft.Json.JsonProperty("signals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Signal> Signals { get; set; }

        [Newtonsoft.Json.JsonProperty("pools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Pool> Pools { get; set; }

        [Newtonsoft.Json.JsonProperty("imports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Import> Imports { get; set; }

        [Newtonsoft.Json.JsonProperty("interfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Interface> Interfaces { get; set; }

        [Newtonsoft.Json.JsonProperty("globalArtifacts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Artifact> GlobalArtifacts { get; set; }

        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Resource> Resources { get; set; }

        [Newtonsoft.Json.JsonProperty("targetNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceSystemId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceSystemId { get; set; }

        [Newtonsoft.Json.JsonProperty("userTaskFormTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> UserTaskFormTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("startEventFormTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StartEventFormTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Errors { get; set; }

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Message> Messages { get; set; }

        [Newtonsoft.Json.JsonProperty("mainProcess", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Process MainProcess { get; set; }

        [Newtonsoft.Json.JsonProperty("messageFlows", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, MessageFlow> MessageFlows { get; set; }

        [Newtonsoft.Json.JsonProperty("escalations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Escalation> Escalations { get; set; }

        [Newtonsoft.Json.JsonProperty("itemDefinitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, ItemDefinition> ItemDefinitions { get; set; }

        [Newtonsoft.Json.JsonProperty("dataStores", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, DataStore> DataStores { get; set; }

        [Newtonsoft.Json.JsonProperty("namespaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Namespaces { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static BpmnModel FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BpmnModel>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CommentRequest
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("author", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Author { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("saveProcessInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SaveProcessInstanceId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static CommentRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CommentRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CommentResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("author", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Author { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static CommentResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CommentResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<object> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseBatchResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BatchResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseBatchResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseBatchResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseDeploymentResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DeploymentResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseDeploymentResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseDeploymentResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseEventSubscriptionResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EventSubscriptionResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseEventSubscriptionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseEventSubscriptionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseExecutionResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ExecutionResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseExecutionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseExecutionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseGroupResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GroupResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseGroupResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseGroupResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseHistoricActivityInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricActivityInstanceResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseHistoricActivityInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseHistoricActivityInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseHistoricDetailResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricDetailResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseHistoricDetailResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseHistoricDetailResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseHistoricProcessInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricProcessInstanceResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseHistoricProcessInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseHistoricProcessInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseHistoricTaskInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricTaskInstanceResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseHistoricTaskInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseHistoricTaskInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseHistoricTaskLogEntryResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricTaskLogEntryResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseHistoricTaskLogEntryResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseHistoricTaskLogEntryResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseHistoricVariableInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricVariableInstanceResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseHistoricVariableInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseHistoricVariableInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseJobResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<JobResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseJobResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseJobResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseListMapStringObject
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<System.Collections.Generic.IDictionary<string, object>>> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseListMapStringObject FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseListMapStringObject>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseModelResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ModelResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseModelResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseModelResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseProcessDefinitionResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ProcessDefinitionResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseProcessDefinitionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseProcessDefinitionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseProcessInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ProcessInstanceResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseProcessInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseProcessInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseTaskResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TaskResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseTaskResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseTaskResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataResponseUserResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<UserResponse> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total { get; set; }

        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataResponseUserResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataResponseUserResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataSpec
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("itemSubjectRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ItemSubjectRef { get; set; }

        [Newtonsoft.Json.JsonProperty("collection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Collection { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataSpec FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataSpec>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DataStore
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("dataState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DataState { get; set; }

        [Newtonsoft.Json.JsonProperty("itemSubjectRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ItemSubjectRef { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DataStore FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DataStore>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DecisionTableResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; }

        [Newtonsoft.Json.JsonProperty("resourceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceName { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DecisionTableResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DecisionTableResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeploymentResourceResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>For a single resource contains the actual URL to use for retrieving the binary resource</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("contentUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentUrl { get; set; }

        /// <summary>Contains the media-type the resource has. This is resolved using a (pluggable) MediaTypeResolver and contains, by default, a limited number of mime-type mappings.</summary>
        [Newtonsoft.Json.JsonProperty("mediaType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MediaType { get; set; }

        /// <summary>Type of resource</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DeploymentResourceResponseType? Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DeploymentResourceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DeploymentResourceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeploymentResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DeploymentTime { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("parentDeploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentDeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DeploymentResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DeploymentResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Escalation
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("escalationCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EscalationCode { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Escalation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Escalation>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EventListener
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Events { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationType { get; set; }

        [Newtonsoft.Json.JsonProperty("implementation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Implementation { get; set; }

        [Newtonsoft.Json.JsonProperty("entityType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EntityType { get; set; }

        [Newtonsoft.Json.JsonProperty("onTransaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OnTransaction { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static EventListener FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<EventListener>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EventResponse
    {
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

        [Newtonsoft.Json.JsonProperty("taskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Message { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static EventResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<EventResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EventSubscriptionResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("eventType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventType { get; set; }

        [Newtonsoft.Json.JsonProperty("eventName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventName { get; set; }

        [Newtonsoft.Json.JsonProperty("activityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("executionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("subScopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }

        [Newtonsoft.Json.JsonProperty("configuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Configuration { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static EventSubscriptionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<EventSubscriptionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecutionActionRequest
    {
        /// <summary>Action to perform: Either signal, trigger, signalEventReceived or messageEventReceived</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Action { get; set; }

        /// <summary>Name of the signal</summary>
        [Newtonsoft.Json.JsonProperty("signalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignalName { get; set; }

        /// <summary>Message of the signal</summary>
        [Newtonsoft.Json.JsonProperty("messageName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MessageName { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("transientVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> TransientVariables { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExecutionActionRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExecutionActionRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecutionChangeActivityStateRequest
    {
        /// <summary>activityIds to be canceled</summary>
        [Newtonsoft.Json.JsonProperty("cancelActivityIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CancelActivityIds { get; set; }

        /// <summary>activityIds to be started</summary>
        [Newtonsoft.Json.JsonProperty("startActivityIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StartActivityIds { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExecutionChangeActivityStateRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExecutionChangeActivityStateRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecutionQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("activityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("parentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("signalEventSubscriptionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignalEventSubscriptionName { get; set; }

        [Newtonsoft.Json.JsonProperty("messageEventSubscriptionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MessageEventSubscriptionName { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> ProcessInstanceVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantIdLike { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutTenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExecutionQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExecutionQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecutionResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("parentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentId { get; set; }

        [Newtonsoft.Json.JsonProperty("parentUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("superExecutionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuperExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("superExecutionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuperExecutionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("suspended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspended { get; set; }

        [Newtonsoft.Json.JsonProperty("activityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExecutionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExecutionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecutionVariableCollectionResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExecutionVariableCollectionResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExecutionVariableCollectionResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExecutionVariableResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExecutionVariableResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExecutionVariableResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExtensionAttribute
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("namespacePrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NamespacePrefix { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExtensionAttribute FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExtensionAttribute>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExtensionElement
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespacePrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NamespacePrefix { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("elementText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ElementText { get; set; }

        [Newtonsoft.Json.JsonProperty("childElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ChildElements { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ExtensionElement FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ExtensionElement>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FieldExtension
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldName { get; set; }

        [Newtonsoft.Json.JsonProperty("stringValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StringValue { get; set; }

        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static FieldExtension FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FieldExtension>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FlowElement
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("documentation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Documentation { get; set; }

        [Newtonsoft.Json.JsonProperty("executionListeners", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FlowableListener> ExecutionListeners { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static FlowElement FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FlowElement>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FlowableListener
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("event", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Event { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationType { get; set; }

        [Newtonsoft.Json.JsonProperty("implementation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Implementation { get; set; }

        [Newtonsoft.Json.JsonProperty("fieldExtensions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FieldExtension> FieldExtensions { get; set; }

        [Newtonsoft.Json.JsonProperty("onTransaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OnTransaction { get; set; }

        [Newtonsoft.Json.JsonProperty("customPropertiesResolverImplementationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomPropertiesResolverImplementationType { get; set; }

        [Newtonsoft.Json.JsonProperty("customPropertiesResolverImplementation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomPropertiesResolverImplementation { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static FlowableListener FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FlowableListener>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FormDataResponse
    {
        [Newtonsoft.Json.JsonProperty("formKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormKey { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("formProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestFormProperty> FormProperties { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static FormDataResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FormDataResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FormDefinitionResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; }

        [Newtonsoft.Json.JsonProperty("resourceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceName { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static FormDefinitionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FormDefinitionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GraphicInfo
    {
        [Newtonsoft.Json.JsonProperty("x", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? X { get; set; }

        [Newtonsoft.Json.JsonProperty("y", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Y { get; set; }

        [Newtonsoft.Json.JsonProperty("height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Height { get; set; }

        [Newtonsoft.Json.JsonProperty("width", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Width { get; set; }

        [Newtonsoft.Json.JsonProperty("element", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BaseElement Element { get; set; }

        [Newtonsoft.Json.JsonProperty("expanded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Expanded { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static GraphicInfo FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GraphicInfo>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GroupRequest
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("nameChanged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NameChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("typeChanged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TypeChanged { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static GroupRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GroupRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GroupResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static GroupResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GroupResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricActivityInstanceQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("activityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("activityInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("activityName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityName { get; set; }

        [Newtonsoft.Json.JsonProperty("activityType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityType { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("finished", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Finished { get; set; }

        [Newtonsoft.Json.JsonProperty("taskAssignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskAssignee { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantIdLike { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutTenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricActivityInstanceQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricActivityInstanceQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricActivityInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("activityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("activityName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityName { get; set; }

        [Newtonsoft.Json.JsonProperty("activityType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityType { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("calledProcessInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CalledProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        [Newtonsoft.Json.JsonProperty("endTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndTime { get; set; }

        [Newtonsoft.Json.JsonProperty("durationInMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DurationInMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricActivityInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricActivityInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricDetailQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("activityInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("selectOnlyFormProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SelectOnlyFormProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("selectOnlyVariableUpdates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SelectOnlyVariableUpdates { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricDetailQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricDetailQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricDetailResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("activityInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

        [Newtonsoft.Json.JsonProperty("detailType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DetailType { get; set; }

        [Newtonsoft.Json.JsonProperty("revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Revision { get; set; }

        [Newtonsoft.Json.JsonProperty("variable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RestVariable Variable { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PropertyId { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PropertyValue { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricDetailResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricDetailResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricIdentityLinkResponse
    {
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricIdentityLinkResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricIdentityLinkResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricProcessInstanceQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProcessInstanceIds { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceName { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceNameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceNameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceNameLikeIgnoreCase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceNameLikeIgnoreCase { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKeyIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProcessDefinitionKeyIn { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKeyNotIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProcessDefinitionKeyNotIn { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionName { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ProcessDefinitionVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionCategory { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentIdIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> DeploymentIdIn { get; set; }

        [Newtonsoft.Json.JsonProperty("superProcessInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuperProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("excludeSubprocesses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcludeSubprocesses { get; set; }

        [Newtonsoft.Json.JsonProperty("finished", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Finished { get; set; }

        [Newtonsoft.Json.JsonProperty("involvedUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvolvedUser { get; set; }

        [Newtonsoft.Json.JsonProperty("finishedAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinishedAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("finishedBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinishedBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("startedAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartedAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("startedBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartedBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("startedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("includeProcessVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeProcessVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantIdLike { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutTenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricProcessInstanceQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricProcessInstanceQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricProcessInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("businessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionName { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionDescription { get; set; }

        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        [Newtonsoft.Json.JsonProperty("endTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndTime { get; set; }

        [Newtonsoft.Json.JsonProperty("durationInMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DurationInMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("startUserId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartUserId { get; set; }

        [Newtonsoft.Json.JsonProperty("startActivityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("endActivityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EndActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeleteReason { get; set; }

        [Newtonsoft.Json.JsonProperty("superProcessInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuperProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackType { get; set; }

        [Newtonsoft.Json.JsonProperty("referenceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceId { get; set; }

        [Newtonsoft.Json.JsonProperty("referenceType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricProcessInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricProcessInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricTaskInstanceQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceIdWithChildren", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceIdWithChildren { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionName { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionNameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionNameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskName { get; set; }

        [Newtonsoft.Json.JsonProperty("taskNameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskNameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDescription { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDescriptionLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDescriptionLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDefinitionKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TaskDefinitionKeys { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskCategory { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDeleteReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDeleteReason { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDeleteReasonLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDeleteReasonLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskAssignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskAssignee { get; set; }

        [Newtonsoft.Json.JsonProperty("taskAssigneeLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskAssigneeLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskOwner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskOwner { get; set; }

        [Newtonsoft.Json.JsonProperty("taskOwnerLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskOwnerLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskInvolvedUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskInvolvedUser { get; set; }

        [Newtonsoft.Json.JsonProperty("taskPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TaskPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("taskMinPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TaskMinPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("taskMaxPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TaskMaxPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("finished", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Finished { get; set; }

        [Newtonsoft.Json.JsonProperty("processFinished", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessFinished { get; set; }

        [Newtonsoft.Json.JsonProperty("parentTaskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentTaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDateAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDateAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDateBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDateBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutDueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutDueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCreatedOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TaskCreatedOn { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCreatedBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TaskCreatedBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCreatedAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TaskCreatedAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCompletedOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TaskCompletedOn { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCompletedBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TaskCompletedBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCompletedAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TaskCompletedAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("includeTaskLocalVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeTaskLocalVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("includeProcessVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeProcessVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("taskVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> TaskVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("processVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> ProcessVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantIdLike { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutTenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutDeleteReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutDeleteReason { get; set; }

        [Newtonsoft.Json.JsonProperty("taskCandidateGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskCandidateGroup { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricTaskInstanceQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricTaskInstanceQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricTaskInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeleteReason { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        [Newtonsoft.Json.JsonProperty("endTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndTime { get; set; }

        [Newtonsoft.Json.JsonProperty("durationInMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DurationInMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("workTimeInMillis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? WorkTimeInMillis { get; set; }

        [Newtonsoft.Json.JsonProperty("claimTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ClaimTime { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("formKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormKey { get; set; }

        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("parentTaskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentTaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("subScopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("propagatedStageInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PropagatedStageInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricTaskInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricTaskInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricTaskLogEntryResponse
    {
        [Newtonsoft.Json.JsonProperty("logNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LogNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("timeStamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TimeStamp { get; set; }

        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Data { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("subScopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricTaskLogEntryResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricTaskLogEntryResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricVariableInstanceQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("excludeTaskVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcludeTaskVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("variableName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VariableName { get; set; }

        [Newtonsoft.Json.JsonProperty("variableNameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VariableNameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> Variables { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricVariableInstanceQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricVariableInstanceQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HistoricVariableInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("variable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RestVariable Variable { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HistoricVariableInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HistoricVariableInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IOSpecification
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("dataInputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DataSpec> DataInputs { get; set; }

        [Newtonsoft.Json.JsonProperty("dataOutputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DataSpec> DataOutputs { get; set; }

        [Newtonsoft.Json.JsonProperty("dataInputRefs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> DataInputRefs { get; set; }

        [Newtonsoft.Json.JsonProperty("dataOutputRefs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> DataOutputRefs { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static IOSpecification FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<IOSpecification>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Import
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("importType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImportType { get; set; }

        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Import FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Import>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class InjectActivityRequest
    {
        [Newtonsoft.Json.JsonProperty("injectionType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InjectionType { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("joinParallelActivitiesOnComplete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JoinParallelActivitiesOnComplete { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static InjectActivityRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<InjectActivityRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Interface
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationRef { get; set; }

        [Newtonsoft.Json.JsonProperty("operations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Operation> Operations { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Interface FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Interface>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemDefinition
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("structureRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StructureRef { get; set; }

        [Newtonsoft.Json.JsonProperty("itemKind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ItemKind { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ItemDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ItemDefinition>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class JobResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("executionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("elementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ElementId { get; set; }

        [Newtonsoft.Json.JsonProperty("elementName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ElementName { get; set; }

        [Newtonsoft.Json.JsonProperty("retries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Retries { get; set; }

        [Newtonsoft.Json.JsonProperty("exceptionMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExceptionMessage { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("createTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreateTime { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static JobResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<JobResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Lane
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("parentProcess", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Process ParentProcess { get; set; }

        [Newtonsoft.Json.JsonProperty("flowReferences", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> FlowReferences { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Lane FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Lane>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MembershipRequest
    {
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static MembershipRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<MembershipRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MembershipResponse
    {
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static MembershipResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<MembershipResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Message
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("itemRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ItemRef { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Message FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Message>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MessageFlow
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceRef { get; set; }

        [Newtonsoft.Json.JsonProperty("targetRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetRef { get; set; }

        [Newtonsoft.Json.JsonProperty("messageRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MessageRef { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static MessageFlow FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<MessageFlow>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ModelRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; }

        [Newtonsoft.Json.JsonProperty("metaInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MetaInfo { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ModelRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ModelRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ModelResponse
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; }

        [Newtonsoft.Json.JsonProperty("metaInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MetaInfo { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("createTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreateTime { get; set; }

        [Newtonsoft.Json.JsonProperty("lastUpdateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastUpdateTime { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceExtraUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceExtraUrl { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ModelResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ModelResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Operation
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("implementationRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImplementationRef { get; set; }

        [Newtonsoft.Json.JsonProperty("inMessageRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InMessageRef { get; set; }

        [Newtonsoft.Json.JsonProperty("outMessageRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OutMessageRef { get; set; }

        [Newtonsoft.Json.JsonProperty("errorMessageRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ErrorMessageRef { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Operation FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Operation>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Pool
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("processRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessRef { get; set; }

        [Newtonsoft.Json.JsonProperty("executable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Executable { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Pool FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Pool>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Process
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("executable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Executable { get; set; }

        [Newtonsoft.Json.JsonProperty("documentation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Documentation { get; set; }

        [Newtonsoft.Json.JsonProperty("ioSpecification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IOSpecification IoSpecification { get; set; }

        [Newtonsoft.Json.JsonProperty("executionListeners", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FlowableListener> ExecutionListeners { get; set; }

        [Newtonsoft.Json.JsonProperty("lanes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Lane> Lanes { get; set; }

        [Newtonsoft.Json.JsonProperty("dataObjects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ValuedDataObject> DataObjects { get; set; }

        [Newtonsoft.Json.JsonProperty("candidateStarterUsers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CandidateStarterUsers { get; set; }

        [Newtonsoft.Json.JsonProperty("candidateStarterGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CandidateStarterGroups { get; set; }

        [Newtonsoft.Json.JsonProperty("eventListeners", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EventListener> EventListeners { get; set; }

        [Newtonsoft.Json.JsonProperty("flowElementMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, FlowElement> FlowElementMap { get; set; }

        [Newtonsoft.Json.JsonProperty("initialFlowElement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlowElement InitialFlowElement { get; set; }

        [Newtonsoft.Json.JsonProperty("enableEagerExecutionTreeFetching", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableEagerExecutionTreeFetching { get; set; }

        [Newtonsoft.Json.JsonProperty("artifacts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Artifact> Artifacts { get; set; }

        [Newtonsoft.Json.JsonProperty("flowElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FlowElement> FlowElements { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Process FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Process>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessDefinitionActionRequest
    {
        /// <summary>Action to perform: Either activate or suspend</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Action { get; set; }

        /// <summary>Whether or not to suspend/activate running process-instances for this process-definition. If omitted, the process-instances are left in the state they are</summary>
        [Newtonsoft.Json.JsonProperty("includeProcessInstances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeProcessInstances { get; set; }

        /// <summary>Date (ISO-8601) when the suspension/activation should be executed. If omitted, the suspend/activation is effective immediately.</summary>
        [Newtonsoft.Json.JsonProperty("date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Date { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessDefinitionActionRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessDefinitionActionRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessDefinitionResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentUrl { get; set; }

        /// <summary>Contains the actual deployed BPMN 2.0 xml.</summary>
        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resource { get; set; }

        /// <summary>Contains a graphical representation of the process, null when no diagram is available.</summary>
        [Newtonsoft.Json.JsonProperty("diagramResource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DiagramResource { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        /// <summary>Indicates the process definition contains graphical information (BPMN DI).</summary>
        [Newtonsoft.Json.JsonProperty("graphicalNotationDefined", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? GraphicalNotationDefined { get; set; }

        [Newtonsoft.Json.JsonProperty("suspended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspended { get; set; }

        [Newtonsoft.Json.JsonProperty("startFormDefined", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StartFormDefined { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessDefinitionResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessDefinitionResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessEngineInfoResponse
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("resourceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("exception", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Exception { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessEngineInfoResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessEngineInfoResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessInstanceActionRequest
    {
        /// <summary>Action to perform: Either activate or suspend</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Action { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessInstanceActionRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessInstanceActionRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    /// <summary>Only one of processDefinitionId, processDefinitionKey or message can be used in the request body</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessInstanceCreateRequest
    {
        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("businessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("transientVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> TransientVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("startFormVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> StartFormVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("outcome", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outcome { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("overrideDefinitionTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OverrideDefinitionTenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("returnVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReturnVariables { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessInstanceCreateRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessInstanceCreateRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessInstanceQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProcessInstanceIds { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceName { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceNameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceNameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceNameLikeIgnoreCase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceNameLikeIgnoreCase { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processBusinessKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessBusinessKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProcessDefinitionIds { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProcessDefinitionKeys { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionName { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionCategory { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ProcessDefinitionVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionEngineVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionEngineVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeploymentId { get; set; }

        [Newtonsoft.Json.JsonProperty("deploymentIdIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> DeploymentIdIn { get; set; }

        [Newtonsoft.Json.JsonProperty("superProcessInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuperProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("subProcessInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("excludeSubprocesses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcludeSubprocesses { get; set; }

        [Newtonsoft.Json.JsonProperty("involvedUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvolvedUser { get; set; }

        [Newtonsoft.Json.JsonProperty("startedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("startedBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartedBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("startedAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartedAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("suspended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspended { get; set; }

        [Newtonsoft.Json.JsonProperty("includeProcessVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeProcessVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantIdLike { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutTenantId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessInstanceQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessInstanceQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessInstanceResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("businessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("suspended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspended { get; set; }

        [Newtonsoft.Json.JsonProperty("ended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ended { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionName { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionDescription { get; set; }

        [Newtonsoft.Json.JsonProperty("activityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActivityId { get; set; }

        [Newtonsoft.Json.JsonProperty("startUserId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartUserId { get; set; }

        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartTime { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }

        [Newtonsoft.Json.JsonProperty("callbackType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackType { get; set; }

        [Newtonsoft.Json.JsonProperty("referenceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceId { get; set; }

        [Newtonsoft.Json.JsonProperty("referenceType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("completed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Completed { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessInstanceResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessInstanceResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessInstanceVariableCollectionResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessInstanceVariableCollectionResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessInstanceVariableCollectionResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessInstanceVariableResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ProcessInstanceVariableResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProcessInstanceVariableResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryVariable
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public QueryVariableOperation? Operation { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static QueryVariable FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<QueryVariable>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Resource
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Resource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Resource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestActionRequest
    {
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static RestActionRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RestActionRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestEnumFormProperty
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static RestEnumFormProperty FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RestEnumFormProperty>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestFormProperty
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("readable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Readable { get; set; }

        [Newtonsoft.Json.JsonProperty("writable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Writable { get; set; }

        [Newtonsoft.Json.JsonProperty("required", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Required { get; set; }

        [Newtonsoft.Json.JsonProperty("datePattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DatePattern { get; set; }

        [Newtonsoft.Json.JsonProperty("enumValues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestEnumFormProperty> EnumValues { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static RestFormProperty FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RestFormProperty>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestIdentityLink
    {
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }

        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static RestIdentityLink FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RestIdentityLink>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestVariable
    {
        /// <summary>Name of the variable</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Type of the variable.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>Value of the variable.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }

        [Newtonsoft.Json.JsonProperty("valueUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ValueUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scope { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static RestVariable FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RestVariable>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Signal
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scope { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Signal FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Signal>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SignalEventReceivedRequest
    {
        /// <summary>Name of the signal</summary>
        [Newtonsoft.Json.JsonProperty("signalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignalName { get; set; }

        /// <summary>Array of variables (in the general variables format) to use as payload to pass along with the signal. Cannot be used in case async is set to true, this will result in an error.</summary>
        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        /// <summary>ID of the tenant that the signal event should be processed in</summary>
        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        /// <summary>If true, handling of the signal will happen asynchronously. Return code will be 202 - Accepted to indicate the request is accepted but not yet executed. If false,
        ///                     handling the signal will be done immediately and result (200 - OK) will only return after this completed successfully. Defaults to false if omitted.</summary>
        [Newtonsoft.Json.JsonProperty("async", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Async { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static SignalEventReceivedRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignalEventReceivedRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SubmitFormRequest
    {
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("businessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestFormProperty> Properties { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static SubmitFormRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SubmitFormRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TableMetaData
    {
        [Newtonsoft.Json.JsonProperty("tableName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TableName { get; set; }

        [Newtonsoft.Json.JsonProperty("columnNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ColumnNames { get; set; }

        [Newtonsoft.Json.JsonProperty("columnTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ColumnTypes { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TableMetaData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TableMetaData>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TableResponse
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TableResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TableResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskActionRequest
    {
        /// <summary>Action to perform: Either complete, claim, delegate or resolve</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Action { get; set; }

        /// <summary>If action is claim or delegate, you can use this parameter to set the assignee associated </summary>
        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        /// <summary>Required when completing a task with a form</summary>
        [Newtonsoft.Json.JsonProperty("formDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormDefinitionId { get; set; }

        /// <summary>Optional outcome value when completing a task with a form</summary>
        [Newtonsoft.Json.JsonProperty("outcome", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outcome { get; set; }

        /// <summary>If action is complete, you can use this parameter to set variables </summary>
        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        /// <summary>If action is complete, you can use this parameter to set transient variables </summary>
        [Newtonsoft.Json.JsonProperty("transientVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> TransientVariables { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskActionRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskActionRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskAttachmentCollectionResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskAttachmentCollectionResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskAttachmentCollectionResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskQueryRequest
    {
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Start { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort { get; set; }

        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Order { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("nameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("descriptionLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DescriptionLike { get; set; }

        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        [Newtonsoft.Json.JsonProperty("minimumPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinimumPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("maximumPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaximumPriority { get; set; }

        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        [Newtonsoft.Json.JsonProperty("assigneeLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AssigneeLike { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("ownerLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OwnerLike { get; set; }

        [Newtonsoft.Json.JsonProperty("unassigned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Unassigned { get; set; }

        [Newtonsoft.Json.JsonProperty("delegationState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DelegationState { get; set; }

        [Newtonsoft.Json.JsonProperty("candidateUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CandidateUser { get; set; }

        [Newtonsoft.Json.JsonProperty("candidateGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CandidateGroup { get; set; }

        [Newtonsoft.Json.JsonProperty("candidateGroupIn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CandidateGroupIn { get; set; }

        [Newtonsoft.Json.JsonProperty("involvedUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvolvedUser { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceIdWithChildren", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceIdWithChildren { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceBusinessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceBusinessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceBusinessKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceBusinessKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionName { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionNameLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionNameLike { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("createdOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedOn { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("createdAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("excludeSubTasks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcludeSubTasks { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKeyLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDefinitionKeyLike { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TaskDefinitionKeys { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("dueBefore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueBefore { get; set; }

        [Newtonsoft.Json.JsonProperty("dueAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutDueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutDueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("active", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Active { get; set; }

        [Newtonsoft.Json.JsonProperty("includeTaskLocalVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeTaskLocalVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("includeProcessVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeProcessVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdLike", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantIdLike { get; set; }

        [Newtonsoft.Json.JsonProperty("withoutTenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WithoutTenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("candidateOrAssigned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CandidateOrAssigned { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("taskVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> TaskVariables { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceVariables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueryVariable> ProcessInstanceVariables { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskQueryRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskQueryRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskRequest
    {
        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        [Newtonsoft.Json.JsonProperty("delegationState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DelegationState { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        [Newtonsoft.Json.JsonProperty("parentTaskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentTaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("formKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormKey { get; set; }

        [Newtonsoft.Json.JsonProperty("ownerSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OwnerSet { get; set; }

        [Newtonsoft.Json.JsonProperty("assigneeSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AssigneeSet { get; set; }

        [Newtonsoft.Json.JsonProperty("delegationStateSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DelegationStateSet { get; set; }

        [Newtonsoft.Json.JsonProperty("nameSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NameSet { get; set; }

        [Newtonsoft.Json.JsonProperty("descriptionSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DescriptionSet { get; set; }

        [Newtonsoft.Json.JsonProperty("duedateSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DuedateSet { get; set; }

        [Newtonsoft.Json.JsonProperty("prioritySet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PrioritySet { get; set; }

        [Newtonsoft.Json.JsonProperty("parentTaskIdSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ParentTaskIdSet { get; set; }

        [Newtonsoft.Json.JsonProperty("categorySet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CategorySet { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantIdSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TenantIdSet { get; set; }

        [Newtonsoft.Json.JsonProperty("formKeySet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FormKeySet { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("assignee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Assignee { get; set; }

        /// <summary>Delegation-state of the task, can be null, "pending" or "resolved".</summary>
        [Newtonsoft.Json.JsonProperty("delegationState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DelegationState { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("createTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreateTime { get; set; }

        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DueDate { get; set; }

        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        [Newtonsoft.Json.JsonProperty("suspended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspended { get; set; }

        [Newtonsoft.Json.JsonProperty("claimTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClaimTime { get; set; }

        [Newtonsoft.Json.JsonProperty("taskDefinitionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskDefinitionKey { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("subScopeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubScopeId { get; set; }

        [Newtonsoft.Json.JsonProperty("scopeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopeType { get; set; }

        [Newtonsoft.Json.JsonProperty("propagatedStageInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PropagatedStageInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("formKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormKey { get; set; }

        [Newtonsoft.Json.JsonProperty("parentTaskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentTaskId { get; set; }

        [Newtonsoft.Json.JsonProperty("parentTaskUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentTaskUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("executionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionId { get; set; }

        [Newtonsoft.Json.JsonProperty("executionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExecutionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("processInstanceUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessInstanceUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionId { get; set; }

        [Newtonsoft.Json.JsonProperty("processDefinitionUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessDefinitionUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RestVariable> Variables { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskVariableCollectionResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskVariableCollectionResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskVariableCollectionResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TaskVariableResource
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static TaskVariableResource FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TaskVariableResource>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class UserInfoRequest
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static UserInfoRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UserInfoRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class UserInfoResponse
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static UserInfoResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UserInfoResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class UserRequest
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FirstName { get; set; }

        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastName { get; set; }

        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("pictureUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PictureUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static UserRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UserRequest>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class UserResponse
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FirstName { get; set; }

        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastName { get; set; }

        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        [Newtonsoft.Json.JsonProperty("pictureUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PictureUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static UserResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<UserResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ValuedDataObject
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlRowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlRowNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("xmlColumnNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? XmlColumnNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("extensionElements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionElement>> ExtensionElements { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ExtensionAttribute>> Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("documentation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Documentation { get; set; }

        [Newtonsoft.Json.JsonProperty("executionListeners", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FlowableListener> ExecutionListeners { get; set; }

        [Newtonsoft.Json.JsonProperty("itemSubjectRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ItemDefinition ItemSubjectRef { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static ValuedDataObject FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ValuedDataObject>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"name")]
        Name = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"type")]
        Type = 2,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"firstName")]
        FirstName = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"lastname")]
        Lastname = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"email")]
        Email = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"displayName")]
        DisplayName = 4,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"dueDate")]
        DueDate = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"executionId")]
        ExecutionId = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"processInstanceId")]
        ProcessInstanceId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"retries")]
        Retries = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 5,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"dueDate")]
        DueDate = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"executionId")]
        ExecutionId = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"processInstanceId")]
        ProcessInstanceId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"retries")]
        Retries = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 5,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"dueDate")]
        DueDate = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"executionId")]
        ExecutionId = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"processInstanceId")]
        ProcessInstanceId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"retries")]
        Retries = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 5,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"dueDate")]
        DueDate = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"executionId")]
        ExecutionId = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"processInstanceId")]
        ProcessInstanceId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"retries")]
        Retries = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 5,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"name")]
        Name = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"deployTime")]
        DeployTime = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 3,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"category")]
        Category = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"createTime")]
        CreateTime = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"key")]
        Key = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"lastUpdateTime")]
        LastUpdateTime = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"name")]
        Name = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"version")]
        Version = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 7,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"name")]
        Name = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"key")]
        Key = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"category")]
        Category = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"deploymentId")]
        DeploymentId = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"version")]
        Version = 5,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"created")]
        Created = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"executionId")]
        ExecutionId = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"processInstanceId")]
        ProcessInstanceId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"processDefinitionId")]
        ProcessDefinitionId = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 5,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"processInstanceId")]
        ProcessInstanceId = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"processDefinitionId")]
        ProcessDefinitionId = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"processDefinitionKey")]
        ProcessDefinitionKey = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 3,

    }

    /// <summary>Property to sort on, to be used together with the order.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Sort12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"id")]
        Id = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"processDefinitionId")]
        ProcessDefinitionId = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"tenantId")]
        TenantId = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"processDefinitionKey")]
        ProcessDefinitionKey = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum DeploymentResourceResponseType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"resource")]
        Resource = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"processDefinition")]
        ProcessDefinition = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"processImage")]
        ProcessImage = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.4.1.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum QueryVariableOperation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"equals")]
        Equals = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"notEquals")]
        NotEquals = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"equalsIgnoreCase")]
        EqualsIgnoreCase = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"notEqualsIgnoreCase")]
        NotEqualsIgnoreCase = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"like")]
        Like = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"likeIgnoreCase")]
        LikeIgnoreCase = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterThan")]
        GreaterThan = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterThanOrEquals")]
        GreaterThanOrEquals = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThan")]
        LessThan = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThanOrEquals")]
        LessThanOrEquals = 9,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FlowableHttpClientException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public FlowableHttpClientException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FlowableHttpClientException<TResult> : FlowableHttpClientException
    {
        public TResult Result { get; private set; }

        public FlowableHttpClientException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
