//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

using Flowable.Sdk.Bpmn.Models;

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"

namespace Flowable.Sdk.Bpmn
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FlowableProcessHttpClient : IFlowableProcessHttpClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public FlowableProcessHttpClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);


        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
        /// <summary>Get form data</summary>
        /// <returns>Indicates that form data could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FormDataResponse> GetFormDataAsync(string taskId, string processDefinitionId)
        {
            return GetFormDataAsync(taskId, processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get form data</summary>
        /// <returns>Indicates that form data could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FormDataResponse> GetFormDataAsync(string taskId, string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("form/form-data?");
            if (taskId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FormDataResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that form data could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Submit task form data</summary>
        /// <returns>Indicates request was successful and the form data was submitted</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessInstanceResponse> SubmitFormAsync(SubmitFormRequest body)
        {
            return SubmitFormAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Submit task form data</summary>
        /// <returns>Indicates request was successful and the form data was submitted</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessInstanceResponse> SubmitFormAsync(SubmitFormRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("form/form-data");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("If TaskId has been provided, Indicates request was successful and the form data was submitted. Returns empty", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List historic activity instances</summary>
        /// <param name="activityId">An id of the activity instance.</param>
        /// <param name="activityInstanceId">An id of the historic activity instance.</param>
        /// <param name="activityName">The name of the historic activity instance.</param>
        /// <param name="activityType">The element type of the historic activity instance.</param>
        /// <param name="executionId">The execution id of the historic activity instance.</param>
        /// <param name="finished">Indication if the historic activity instance is finished.</param>
        /// <param name="taskAssignee">The assignee of the historic activity instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic activity instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic activity instance.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic activity instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> ListHistoricActivityInstancesAsync(string activityId, string activityInstanceId, string activityName, string activityType, string executionId, bool? finished, string taskAssignee, string processInstanceId, string processDefinitionId, string tenantId, string tenantIdLike, bool? withoutTenantId)
        {
            return ListHistoricActivityInstancesAsync(activityId, activityInstanceId, activityName, activityType, executionId, finished, taskAssignee, processInstanceId, processDefinitionId, tenantId, tenantIdLike, withoutTenantId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List historic activity instances</summary>
        /// <param name="activityId">An id of the activity instance.</param>
        /// <param name="activityInstanceId">An id of the historic activity instance.</param>
        /// <param name="activityName">The name of the historic activity instance.</param>
        /// <param name="activityType">The element type of the historic activity instance.</param>
        /// <param name="executionId">The execution id of the historic activity instance.</param>
        /// <param name="finished">Indication if the historic activity instance is finished.</param>
        /// <param name="taskAssignee">The assignee of the historic activity instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic activity instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic activity instance.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic activity instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> ListHistoricActivityInstancesAsync(string activityId, string activityInstanceId, string activityName, string activityType, string executionId, bool? finished, string taskAssignee, string processInstanceId, string processDefinitionId, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-activity-instances?");
            if (activityId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (activityInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (activityName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (activityType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (finished != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("finished") + "=").Append(System.Uri.EscapeDataString(ConvertToString(finished, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskAssignee != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskAssignee") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskAssignee, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricActivityInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get historic detail</summary>
        /// <param name="id">The id of the historic detail.</param>
        /// <param name="processInstanceId">The process instance id of the historic detail.</param>
        /// <param name="executionId">The execution id of the historic detail.</param>
        /// <param name="activityInstanceId">The activity instance id of the historic detail.</param>
        /// <param name="taskId">The task id of the historic detail.</param>
        /// <param name="selectOnlyFormProperties">Indication to only return form properties in the result.</param>
        /// <param name="selectOnlyVariableUpdates">Indication to only return variable updates in the result.</param>
        /// <returns>Indicates that historic detail could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> ListHistoricDetailsAsync(string id, string processInstanceId, string executionId, string activityInstanceId, string taskId, bool? selectOnlyFormProperties, bool? selectOnlyVariableUpdates)
        {
            return ListHistoricDetailsAsync(id, processInstanceId, executionId, activityInstanceId, taskId, selectOnlyFormProperties, selectOnlyVariableUpdates, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get historic detail</summary>
        /// <param name="id">The id of the historic detail.</param>
        /// <param name="processInstanceId">The process instance id of the historic detail.</param>
        /// <param name="executionId">The execution id of the historic detail.</param>
        /// <param name="activityInstanceId">The activity instance id of the historic detail.</param>
        /// <param name="taskId">The task id of the historic detail.</param>
        /// <param name="selectOnlyFormProperties">Indication to only return form properties in the result.</param>
        /// <param name="selectOnlyVariableUpdates">Indication to only return variable updates in the result.</param>
        /// <returns>Indicates that historic detail could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> ListHistoricDetailsAsync(string id, string processInstanceId, string executionId, string activityInstanceId, string taskId, bool? selectOnlyFormProperties, bool? selectOnlyVariableUpdates, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-detail?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (activityInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (selectOnlyFormProperties != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("selectOnlyFormProperties") + "=").Append(System.Uri.EscapeDataString(ConvertToString(selectOnlyFormProperties, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (selectOnlyVariableUpdates != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("selectOnlyVariableUpdates") + "=").Append(System.Uri.EscapeDataString(ConvertToString(selectOnlyVariableUpdates, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricDetailResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for a historic detail variable</summary>
        /// <returns>Indicates the historic detail instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricDetailVariableDataAsync(string detailId)
        {
            return GetHistoricDetailVariableDataAsync(detailId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic detail variable</summary>
        /// <returns>Indicates the historic detail instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricDetailVariableDataAsync(string detailId, System.Threading.CancellationToken cancellationToken)
        {
            if (detailId == null)
                throw new System.ArgumentNullException("detailId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-detail/{detailId}/data");
            urlBuilder_.Replace("{detailId}", System.Uri.EscapeDataString(ConvertToString(detailId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested historic detail instance was not found or the historic detail instance does not have a variable with the given name or the variable does not have a binary stream available. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of historic process instances</summary>
        /// <param name="processInstanceId">An id of the historic process instance.</param>
        /// <param name="processInstanceName">A name of the historic process instance.</param>
        /// <param name="processInstanceNameLike">A name of the historic process instance used in a like query.</param>
        /// <param name="processInstanceNameLikeIgnoreCase">A name of the historic process instance used in a like query ignoring case.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic process instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic process instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic process instance.</param>
        /// <param name="processDefinitionCategory">The process definition category of the historic process instance.</param>
        /// <param name="processDefinitionVersion">The process definition version of the historic process instance.</param>
        /// <param name="deploymentId">The deployment id of the historic process instance.</param>
        /// <param name="businessKey">The business key of the historic process instance.</param>
        /// <param name="businessKeyLike">Only return instances with a businessKey like this key.</param>
        /// <param name="involvedUser">An involved user of the historic process instance.</param>
        /// <param name="finished">Indication if the historic process instance is finished.</param>
        /// <param name="superProcessInstanceId">An optional parent process id of the historic process instance.</param>
        /// <param name="excludeSubprocesses">Return only historic process instances which are not sub processes.</param>
        /// <param name="finishedAfter">Return only historic process instances that were finished after this date.</param>
        /// <param name="finishedBefore">Return only historic process instances that were finished before this date.</param>
        /// <param name="startedAfter">Return only historic process instances that were started after this date.</param>
        /// <param name="startedBefore">Return only historic process instances that were started before this date.</param>
        /// <param name="startedBy">Return only historic process instances that were started by this user.</param>
        /// <param name="includeProcessVariables">An indication if the historic process instance variables should be returned as well.</param>
        /// <param name="callbackId">Only return instances with the given callbackId.</param>
        /// <param name="callbackType">Only return instances with the given callbackType.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic process instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> ListHistoricProcessInstancesAsync(string processInstanceId, string processInstanceName, string processInstanceNameLike, string processInstanceNameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionName, string processDefinitionCategory, string processDefinitionVersion, string deploymentId, string businessKey, string businessKeyLike, string involvedUser, bool? finished, string superProcessInstanceId, bool? excludeSubprocesses, System.DateTimeOffset? finishedAfter, System.DateTimeOffset? finishedBefore, System.DateTimeOffset? startedAfter, System.DateTimeOffset? startedBefore, string startedBy, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId)
        {
            return ListHistoricProcessInstancesAsync(processInstanceId, processInstanceName, processInstanceNameLike, processInstanceNameLikeIgnoreCase, processDefinitionKey, processDefinitionId, processDefinitionName, processDefinitionCategory, processDefinitionVersion, deploymentId, businessKey, businessKeyLike, involvedUser, finished, superProcessInstanceId, excludeSubprocesses, finishedAfter, finishedBefore, startedAfter, startedBefore, startedBy, includeProcessVariables, callbackId, callbackType, tenantId, tenantIdLike, withoutTenantId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of historic process instances</summary>
        /// <param name="processInstanceId">An id of the historic process instance.</param>
        /// <param name="processInstanceName">A name of the historic process instance.</param>
        /// <param name="processInstanceNameLike">A name of the historic process instance used in a like query.</param>
        /// <param name="processInstanceNameLikeIgnoreCase">A name of the historic process instance used in a like query ignoring case.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic process instance.</param>
        /// <param name="processDefinitionId">The process definition id of the historic process instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic process instance.</param>
        /// <param name="processDefinitionCategory">The process definition category of the historic process instance.</param>
        /// <param name="processDefinitionVersion">The process definition version of the historic process instance.</param>
        /// <param name="deploymentId">The deployment id of the historic process instance.</param>
        /// <param name="businessKey">The business key of the historic process instance.</param>
        /// <param name="businessKeyLike">Only return instances with a businessKey like this key.</param>
        /// <param name="involvedUser">An involved user of the historic process instance.</param>
        /// <param name="finished">Indication if the historic process instance is finished.</param>
        /// <param name="superProcessInstanceId">An optional parent process id of the historic process instance.</param>
        /// <param name="excludeSubprocesses">Return only historic process instances which are not sub processes.</param>
        /// <param name="finishedAfter">Return only historic process instances that were finished after this date.</param>
        /// <param name="finishedBefore">Return only historic process instances that were finished before this date.</param>
        /// <param name="startedAfter">Return only historic process instances that were started after this date.</param>
        /// <param name="startedBefore">Return only historic process instances that were started before this date.</param>
        /// <param name="startedBy">Return only historic process instances that were started by this user.</param>
        /// <param name="includeProcessVariables">An indication if the historic process instance variables should be returned as well.</param>
        /// <param name="callbackId">Only return instances with the given callbackId.</param>
        /// <param name="callbackType">Only return instances with the given callbackType.</param>
        /// <param name="tenantId">Only return instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic process instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> ListHistoricProcessInstancesAsync(string processInstanceId, string processInstanceName, string processInstanceNameLike, string processInstanceNameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionName, string processDefinitionCategory, string processDefinitionVersion, string deploymentId, string businessKey, string businessKeyLike, string involvedUser, bool? finished, string superProcessInstanceId, bool? excludeSubprocesses, System.DateTimeOffset? finishedAfter, System.DateTimeOffset? finishedBefore, System.DateTimeOffset? startedAfter, System.DateTimeOffset? startedBefore, string startedBy, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances?");
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceNameLikeIgnoreCase != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceNameLikeIgnoreCase") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceNameLikeIgnoreCase, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionCategory != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionCategory") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionCategory, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deploymentId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deploymentId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (businessKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("businessKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(businessKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (businessKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("businessKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(businessKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (involvedUser != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("involvedUser") + "=").Append(System.Uri.EscapeDataString(ConvertToString(involvedUser, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (finished != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("finished") + "=").Append(System.Uri.EscapeDataString(ConvertToString(finished, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (superProcessInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("superProcessInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(superProcessInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (excludeSubprocesses != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("excludeSubprocesses") + "=").Append(System.Uri.EscapeDataString(ConvertToString(excludeSubprocesses, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (finishedAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("finishedAfter") + "=").Append(System.Uri.EscapeDataString(finishedAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (finishedBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("finishedBefore") + "=").Append(System.Uri.EscapeDataString(finishedBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startedAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startedAfter") + "=").Append(System.Uri.EscapeDataString(startedAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startedBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startedBefore") + "=").Append(System.Uri.EscapeDataString(startedBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startedBy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startedBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startedBy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeProcessVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeProcessVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeProcessVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (callbackId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("callbackId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(callbackId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (callbackType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("callbackType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(callbackType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a historic process instance</summary>
        /// <returns>Indicates that the historic process instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HistoricProcessInstanceResponse> GetHistoricProcessInstanceAsync(string processInstanceId)
        {
            return GetHistoricProcessInstanceAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a historic process instance</summary>
        /// <returns>Indicates that the historic process instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HistoricProcessInstanceResponse> GetHistoricProcessInstanceAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HistoricProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that the historic process instances could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a historic process instance</summary>
        /// <returns>Indicates that the historic process instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteHistoricProcessInstanceAsync(string processInstanceId)
        {
            return DeleteHistoricProcessInstanceAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a historic process instance</summary>
        /// <returns>Indicates that the historic process instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteHistoricProcessInstanceAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that the historic process instance could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List comments on a historic process instance</summary>
        /// <returns>Indicates the process instance was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListHistoricProcessInstanceCommentsAsync(string processInstanceId)
        {
            return ListHistoricProcessInstanceCommentsAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List comments on a historic process instance</summary>
        /// <returns>Indicates the process instance was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListHistoricProcessInstanceCommentsAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}/comments");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CommentResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that the historic process instance could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a new comment on a historic process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentResponse> CreateCommentAsync(string processInstanceId, CommentResponse body)
        {
            return CreateCommentAsync(processInstanceId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new comment on a historic process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentResponse> CreateCommentAsync(string processInstanceId, CommentResponse body, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}/comments");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the comment was created and the result is returned.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the comment is missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that the historic process instance could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentResponse> GetCommentAsync(string processInstanceId, string commentId)
        {
            return GetCommentAsync(processInstanceId, commentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentResponse> GetCommentAsync(string processInstanceId, string commentId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (commentId == null)
                throw new System.ArgumentNullException("commentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}/comments/{commentId}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{commentId}", System.Uri.EscapeDataString(ConvertToString(commentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested historic process instance was not found or the historic process instance does not have a comment with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteCommentAsync(string processInstanceId, string commentId)
        {
            return DeleteCommentAsync(processInstanceId, commentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a comment on a historic process instance</summary>
        /// <returns>Indicates the historic process instance and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteCommentAsync(string processInstanceId, string commentId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (commentId == null)
                throw new System.ArgumentNullException("commentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}/comments/{commentId}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{commentId}", System.Uri.EscapeDataString(ConvertToString(commentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested historic process instance was not found or the historic process instance does not have a comment with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List identity links of a historic process instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricProcessInstanceIdentityLinksAsync(string processInstanceId)
        {
            return ListHistoricProcessInstanceIdentityLinksAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links of a historic process instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricProcessInstanceIdentityLinksAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}/identitylinks");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the process instance could not be found..", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for a historic process instance variable</summary>
        /// <returns>Indicates the process instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricProcessInstanceVariableDataAsync(string processInstanceId, string variableName)
        {
            return GetHistoricProcessInstanceVariableDataAsync(processInstanceId, variableName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic process instance variable</summary>
        /// <returns>Indicates the process instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricProcessInstanceVariableDataAsync(string processInstanceId, string variableName, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-process-instances/{processInstanceId}/variables/{variableName}/data");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found or the process instance does not have a variable with the given name or the variable does not have a binary stream available. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List historic task instances</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic task instance.</param>
        /// <param name="processInstanceIdWithChildren">Selects the historic task instances for the process instance and its children.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic task instance.</param>
        /// <param name="processDefinitionKeyLike">The process definition key of the historic task instance, which matches the given value.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic task instance.</param>
        /// <param name="processDefinitionNameLike">The process definition name of the historic task instance, which matches the given value.</param>
        /// <param name="processBusinessKey">The process instance business key of the historic task instance.</param>
        /// <param name="processBusinessKeyLike">The process instance business key of the historic task instance that matches the given value.</param>
        /// <param name="executionId">The execution id of the historic task instance.</param>
        /// <param name="taskDefinitionKey">The task definition key for tasks part of a process</param>
        /// <param name="taskDefinitionKeys">The task definition key for tasks part of a process</param>
        /// <param name="taskName">The task name of the historic task instance.</param>
        /// <param name="taskNameLike">The task name with like operator for the historic task instance.</param>
        /// <param name="taskDescription">The task description of the historic task instance.</param>
        /// <param name="taskDescriptionLike">The task description with like operator for the historic task instance.</param>
        /// <param name="taskCategory">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <param name="taskDeleteReason">The task delete reason of the historic task instance.</param>
        /// <param name="taskDeleteReasonLike">The task delete reason with like operator for the historic task instance.</param>
        /// <param name="taskAssignee">The assignee of the historic task instance.</param>
        /// <param name="taskAssigneeLike">The assignee with like operator for the historic task instance.</param>
        /// <param name="taskOwner">The owner of the historic task instance.</param>
        /// <param name="taskOwnerLike">The owner with like operator for the historic task instance.</param>
        /// <param name="taskInvolvedUser">An involved user of the historic task instance</param>
        /// <param name="taskPriority">The priority of the historic task instance.</param>
        /// <param name="finished">Indication if the historic task instance is finished.</param>
        /// <param name="processFinished">Indication if the process instance of the historic task instance is finished.</param>
        /// <param name="parentTaskId">An optional parent task id of the historic task instance.</param>
        /// <param name="dueDate">Return only historic task instances that have a due date equal this date.</param>
        /// <param name="dueDateAfter">Return only historic task instances that have a due date after this date.</param>
        /// <param name="dueDateBefore">Return only historic task instances that have a due date before this date.</param>
        /// <param name="withoutDueDate">Return only historic task instances that have no due-date. When false is provided as value, this parameter is ignored.</param>
        /// <param name="taskCompletedOn">Return only historic task instances that have been completed on this date.</param>
        /// <param name="taskCompletedAfter">Return only historic task instances that have been completed after this date.</param>
        /// <param name="taskCompletedBefore">Return only historic task instances that have been completed before this date.</param>
        /// <param name="taskCreatedOn">Return only historic task instances that were created on this date.</param>
        /// <param name="taskCreatedBefore">Return only historic task instances that were created before this date.</param>
        /// <param name="taskCreatedAfter">Return only historic task instances that were created after this date.</param>
        /// <param name="includeTaskLocalVariables">An indication if the historic task instance local variables should be returned as well.</param>
        /// <param name="includeProcessVariables">An indication if the historic task instance global variables should be returned as well.</param>
        /// <param name="scopeDefinitionId">Only return historic task instances with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return historic task instances with the given scopeId.</param>
        /// <param name="scopeType">Only return historic task instances with the given scopeType.</param>
        /// <param name="tenantId">Only return historic task instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return historic task instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns historic task instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic task instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> ListHistoricTaskInstancesAsync(string taskId, string processInstanceId, string processInstanceIdWithChildren, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionId, string processDefinitionName, string processDefinitionNameLike, string processBusinessKey, string processBusinessKeyLike, string executionId, string taskDefinitionKey, string taskDefinitionKeys, string taskName, string taskNameLike, string taskDescription, string taskDescriptionLike, string taskCategory, string taskDeleteReason, string taskDeleteReasonLike, string taskAssignee, string taskAssigneeLike, string taskOwner, string taskOwnerLike, string taskInvolvedUser, string taskPriority, bool? finished, bool? processFinished, string parentTaskId, System.DateTimeOffset? dueDate, System.DateTimeOffset? dueDateAfter, System.DateTimeOffset? dueDateBefore, bool? withoutDueDate, System.DateTimeOffset? taskCompletedOn, System.DateTimeOffset? taskCompletedAfter, System.DateTimeOffset? taskCompletedBefore, System.DateTimeOffset? taskCreatedOn, System.DateTimeOffset? taskCreatedBefore, System.DateTimeOffset? taskCreatedAfter, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId)
        {
            return ListHistoricTaskInstancesAsync(taskId, processInstanceId, processInstanceIdWithChildren, processDefinitionKey, processDefinitionKeyLike, processDefinitionId, processDefinitionName, processDefinitionNameLike, processBusinessKey, processBusinessKeyLike, executionId, taskDefinitionKey, taskDefinitionKeys, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskCategory, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskInvolvedUser, taskPriority, finished, processFinished, parentTaskId, dueDate, dueDateAfter, dueDateBefore, withoutDueDate, taskCompletedOn, taskCompletedAfter, taskCompletedBefore, taskCreatedOn, taskCreatedBefore, taskCreatedAfter, includeTaskLocalVariables, includeProcessVariables, scopeDefinitionId, scopeId, scopeType, tenantId, tenantIdLike, withoutTenantId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List historic task instances</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="processInstanceId">The process instance id of the historic task instance.</param>
        /// <param name="processInstanceIdWithChildren">Selects the historic task instances for the process instance and its children.</param>
        /// <param name="processDefinitionKey">The process definition key of the historic task instance.</param>
        /// <param name="processDefinitionKeyLike">The process definition key of the historic task instance, which matches the given value.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task instance.</param>
        /// <param name="processDefinitionName">The process definition name of the historic task instance.</param>
        /// <param name="processDefinitionNameLike">The process definition name of the historic task instance, which matches the given value.</param>
        /// <param name="processBusinessKey">The process instance business key of the historic task instance.</param>
        /// <param name="processBusinessKeyLike">The process instance business key of the historic task instance that matches the given value.</param>
        /// <param name="executionId">The execution id of the historic task instance.</param>
        /// <param name="taskDefinitionKey">The task definition key for tasks part of a process</param>
        /// <param name="taskDefinitionKeys">The task definition key for tasks part of a process</param>
        /// <param name="taskName">The task name of the historic task instance.</param>
        /// <param name="taskNameLike">The task name with like operator for the historic task instance.</param>
        /// <param name="taskDescription">The task description of the historic task instance.</param>
        /// <param name="taskDescriptionLike">The task description with like operator for the historic task instance.</param>
        /// <param name="taskCategory">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <param name="taskDeleteReason">The task delete reason of the historic task instance.</param>
        /// <param name="taskDeleteReasonLike">The task delete reason with like operator for the historic task instance.</param>
        /// <param name="taskAssignee">The assignee of the historic task instance.</param>
        /// <param name="taskAssigneeLike">The assignee with like operator for the historic task instance.</param>
        /// <param name="taskOwner">The owner of the historic task instance.</param>
        /// <param name="taskOwnerLike">The owner with like operator for the historic task instance.</param>
        /// <param name="taskInvolvedUser">An involved user of the historic task instance</param>
        /// <param name="taskPriority">The priority of the historic task instance.</param>
        /// <param name="finished">Indication if the historic task instance is finished.</param>
        /// <param name="processFinished">Indication if the process instance of the historic task instance is finished.</param>
        /// <param name="parentTaskId">An optional parent task id of the historic task instance.</param>
        /// <param name="dueDate">Return only historic task instances that have a due date equal this date.</param>
        /// <param name="dueDateAfter">Return only historic task instances that have a due date after this date.</param>
        /// <param name="dueDateBefore">Return only historic task instances that have a due date before this date.</param>
        /// <param name="withoutDueDate">Return only historic task instances that have no due-date. When false is provided as value, this parameter is ignored.</param>
        /// <param name="taskCompletedOn">Return only historic task instances that have been completed on this date.</param>
        /// <param name="taskCompletedAfter">Return only historic task instances that have been completed after this date.</param>
        /// <param name="taskCompletedBefore">Return only historic task instances that have been completed before this date.</param>
        /// <param name="taskCreatedOn">Return only historic task instances that were created on this date.</param>
        /// <param name="taskCreatedBefore">Return only historic task instances that were created before this date.</param>
        /// <param name="taskCreatedAfter">Return only historic task instances that were created after this date.</param>
        /// <param name="includeTaskLocalVariables">An indication if the historic task instance local variables should be returned as well.</param>
        /// <param name="includeProcessVariables">An indication if the historic task instance global variables should be returned as well.</param>
        /// <param name="scopeDefinitionId">Only return historic task instances with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return historic task instances with the given scopeId.</param>
        /// <param name="scopeType">Only return historic task instances with the given scopeType.</param>
        /// <param name="tenantId">Only return historic task instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return historic task instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns historic task instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates that historic task instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> ListHistoricTaskInstancesAsync(string taskId, string processInstanceId, string processInstanceIdWithChildren, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionId, string processDefinitionName, string processDefinitionNameLike, string processBusinessKey, string processBusinessKeyLike, string executionId, string taskDefinitionKey, string taskDefinitionKeys, string taskName, string taskNameLike, string taskDescription, string taskDescriptionLike, string taskCategory, string taskDeleteReason, string taskDeleteReasonLike, string taskAssignee, string taskAssigneeLike, string taskOwner, string taskOwnerLike, string taskInvolvedUser, string taskPriority, bool? finished, bool? processFinished, string parentTaskId, System.DateTimeOffset? dueDate, System.DateTimeOffset? dueDateAfter, System.DateTimeOffset? dueDateBefore, bool? withoutDueDate, System.DateTimeOffset? taskCompletedOn, System.DateTimeOffset? taskCompletedAfter, System.DateTimeOffset? taskCompletedBefore, System.DateTimeOffset? taskCreatedOn, System.DateTimeOffset? taskCreatedBefore, System.DateTimeOffset? taskCreatedAfter, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-instances?");
            if (taskId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceIdWithChildren != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceIdWithChildren") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceIdWithChildren, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processBusinessKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processBusinessKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processBusinessKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processBusinessKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processBusinessKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processBusinessKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDefinitionKeys != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDefinitionKeys") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDefinitionKeys, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDescription != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDescription") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDescription, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDescriptionLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDescriptionLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDescriptionLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCategory != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCategory") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskCategory, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDeleteReason != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDeleteReason") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDeleteReason, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDeleteReasonLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDeleteReasonLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDeleteReasonLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskAssignee != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskAssignee") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskAssignee, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskAssigneeLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskAssigneeLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskAssigneeLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskOwner != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskOwner") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskOwner, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskOwnerLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskOwnerLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskOwnerLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskInvolvedUser != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskInvolvedUser") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskInvolvedUser, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskPriority != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskPriority") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskPriority, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (finished != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("finished") + "=").Append(System.Uri.EscapeDataString(ConvertToString(finished, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processFinished != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processFinished") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processFinished, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (parentTaskId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("parentTaskId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(parentTaskId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueDate != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueDate") + "=").Append(System.Uri.EscapeDataString(dueDate.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueDateAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueDateAfter") + "=").Append(System.Uri.EscapeDataString(dueDateAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueDateBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueDateBefore") + "=").Append(System.Uri.EscapeDataString(dueDateBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutDueDate != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutDueDate") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutDueDate, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCompletedOn != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCompletedOn") + "=").Append(System.Uri.EscapeDataString(taskCompletedOn.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCompletedAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCompletedAfter") + "=").Append(System.Uri.EscapeDataString(taskCompletedAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCompletedBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCompletedBefore") + "=").Append(System.Uri.EscapeDataString(taskCompletedBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCreatedOn != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCreatedOn") + "=").Append(System.Uri.EscapeDataString(taskCreatedOn.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCreatedBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCreatedBefore") + "=").Append(System.Uri.EscapeDataString(taskCreatedBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskCreatedAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskCreatedAfter") + "=").Append(System.Uri.EscapeDataString(taskCreatedAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeTaskLocalVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeTaskLocalVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeTaskLocalVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeProcessVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeProcessVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeProcessVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricTaskInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single historic task instance</summary>
        /// <returns>Indicates that the historic task instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<HistoricTaskInstanceResponse> GetTaskInstanceAsync(string taskId)
        {
            return GetTaskInstanceAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single historic task instance</summary>
        /// <returns>Indicates that the historic task instances could be found.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<HistoricTaskInstanceResponse> GetTaskInstanceAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-instances/{taskId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HistoricTaskInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that the historic task instances could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a historic task instance</summary>
        /// <returns>Indicates that the historic task instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTaskInstanceAsync(string taskId)
        {
            return DeleteTaskInstanceAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a historic task instance</summary>
        /// <returns>Indicates that the historic task instance was deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTaskInstanceAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-instances/{taskId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates that the historic task instance could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a historic task instance form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetHistoricTaskFormAsync(string taskId)
        {
            return GetHistoricTaskFormAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a historic task instance form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetHistoricTaskFormAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-instances/{taskId}/form");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List identity links of a historic task instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricTaskInstanceIdentityLinksAsync(string taskId)
        {
            return ListHistoricTaskInstanceIdentityLinksAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links of a historic task instance</summary>
        /// <returns>Indicates request was successful and the identity links are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>> ListHistoricTaskInstanceIdentityLinksAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-instances/{taskId}/identitylinks");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<HistoricIdentityLinkResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the task instance could not be found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the task instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricTaskInstanceVariableDataAsync(string taskId, string variableName, string scope)
        {
            return GetHistoricTaskInstanceVariableDataAsync(taskId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the task instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricTaskInstanceVariableDataAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-instances/{taskId}/variables/{variableName}/data?");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task instance was not found or the process instance does not have a variable with the given name or the variable does not have a binary stream available. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List historic task log entries</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="type">The type of the log entry.</param>
        /// <param name="userId">The user who produced the task change.</param>
        /// <param name="processInstanceId">The process instance id of the historic task log entry.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task log entry.</param>
        /// <param name="scopeId">Only return historic task log entries with the given scopeId.</param>
        /// <param name="scopeDefinitionId">Only return historic task log entries with the given scopeDefinitionId.</param>
        /// <param name="subScopeId">Only return historic task log entries with the given subScopeId</param>
        /// <param name="scopeType">Only return historic task log entries with the given scopeType.</param>
        /// <param name="from">Return task log entries starting from a date.</param>
        /// <param name="to">Return task log entries up to a date.</param>
        /// <param name="tenantId">Only return historic task log entries with the given tenantId.</param>
        /// <param name="fromLogNumber">Return task log entries starting from a log number</param>
        /// <param name="toLogNumber">Return task log entries up to specific a log number</param>
        /// <returns>Indicates that historic task log entries could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricTaskLogEntryResponse> GetHistoricTaskLogEntriesAsync(string taskId, string type, string userId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, string subScopeId, string scopeType, System.DateTimeOffset? from, System.DateTimeOffset? to, string tenantId, string fromLogNumber, string toLogNumber)
        {
            return GetHistoricTaskLogEntriesAsync(taskId, type, userId, processInstanceId, processDefinitionId, scopeId, scopeDefinitionId, subScopeId, scopeType, from, to, tenantId, fromLogNumber, toLogNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List historic task log entries</summary>
        /// <param name="taskId">An id of the historic task instance.</param>
        /// <param name="type">The type of the log entry.</param>
        /// <param name="userId">The user who produced the task change.</param>
        /// <param name="processInstanceId">The process instance id of the historic task log entry.</param>
        /// <param name="processDefinitionId">The process definition id of the historic task log entry.</param>
        /// <param name="scopeId">Only return historic task log entries with the given scopeId.</param>
        /// <param name="scopeDefinitionId">Only return historic task log entries with the given scopeDefinitionId.</param>
        /// <param name="subScopeId">Only return historic task log entries with the given subScopeId</param>
        /// <param name="scopeType">Only return historic task log entries with the given scopeType.</param>
        /// <param name="from">Return task log entries starting from a date.</param>
        /// <param name="to">Return task log entries up to a date.</param>
        /// <param name="tenantId">Only return historic task log entries with the given tenantId.</param>
        /// <param name="fromLogNumber">Return task log entries starting from a log number</param>
        /// <param name="toLogNumber">Return task log entries up to specific a log number</param>
        /// <returns>Indicates that historic task log entries could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricTaskLogEntryResponse> GetHistoricTaskLogEntriesAsync(string taskId, string type, string userId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, string subScopeId, string scopeType, System.DateTimeOffset? from, System.DateTimeOffset? to, string tenantId, string fromLogNumber, string toLogNumber, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-task-log-entries?");
            if (taskId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (type != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("type") + "=").Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (userId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("userId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (subScopeId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("subScopeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(subScopeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (from != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("from") + "=").Append(System.Uri.EscapeDataString(from.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (to != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("to") + "=").Append(System.Uri.EscapeDataString(to.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fromLogNumber != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fromLogNumber") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fromLogNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (toLogNumber != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("toLogNumber") + "=").Append(System.Uri.EscapeDataString(ConvertToString(toLogNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricTaskLogEntryResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of historic variable instances</summary>
        /// <param name="processInstanceId">The process instance id of the historic variable instance.</param>
        /// <param name="taskId">The task id of the historic variable instance.</param>
        /// <param name="excludeTaskVariables">Indication to exclude the task variables from the result.</param>
        /// <param name="variableName">The variable name of the historic variable instance.</param>
        /// <param name="variableNameLike">The variable name using the like operator for the historic variable instance.</param>
        /// <returns>Indicates that historic variable instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> ListHistoricVariableInstancesAsync(string processInstanceId, string taskId, bool? excludeTaskVariables, string variableName, string variableNameLike)
        {
            return ListHistoricVariableInstancesAsync(processInstanceId, taskId, excludeTaskVariables, variableName, variableNameLike, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of historic variable instances</summary>
        /// <param name="processInstanceId">The process instance id of the historic variable instance.</param>
        /// <param name="taskId">The task id of the historic variable instance.</param>
        /// <param name="excludeTaskVariables">Indication to exclude the task variables from the result.</param>
        /// <param name="variableName">The variable name of the historic variable instance.</param>
        /// <param name="variableNameLike">The variable name using the like operator for the historic variable instance.</param>
        /// <returns>Indicates that historic variable instances could be queried.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> ListHistoricVariableInstancesAsync(string processInstanceId, string taskId, bool? excludeTaskVariables, string variableName, string variableNameLike, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-variable-instances?");
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (excludeTaskVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("excludeTaskVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(excludeTaskVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (variableName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("variableName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (variableNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("variableNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(variableNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricVariableInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the variable instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricInstanceVariableDataAsync(string varInstanceId)
        {
            return GetHistoricInstanceVariableDataAsync(varInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a historic task instance variable</summary>
        /// <returns>Indicates the variable instance was found and the requested variable data is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetHistoricInstanceVariableDataAsync(string varInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (varInstanceId == null)
                throw new System.ArgumentNullException("varInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("history/historic-variable-instances/{varInstanceId}/data");
            urlBuilder_.Replace("{varInstanceId}", System.Uri.EscapeDataString(ConvertToString(varInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested variable instance was not found or the variable instance does not have a variable with the given name or the variable does not have a binary stream available. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List groups</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="name">Only return groups with the given name</param>
        /// <param name="type">Only return groups with the given type</param>
        /// <param name="nameLike">Only return groups with a name like the given value. Use % as wildcard-character.</param>
        /// <param name="member">Only return groups which have a member with the given username.</param>
        /// <param name="potentialStarter">Only return groups which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested groups were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseGroupResponse> ListGroupsAsync(string id, string name, string type, string nameLike, string member, string potentialStarter, Sort? sort)
        {
            return ListGroupsAsync(id, name, type, nameLike, member, potentialStarter, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List groups</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="name">Only return groups with the given name</param>
        /// <param name="type">Only return groups with the given type</param>
        /// <param name="nameLike">Only return groups with a name like the given value. Use % as wildcard-character.</param>
        /// <param name="member">Only return groups which have a member with the given username.</param>
        /// <param name="potentialStarter">Only return groups which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested groups were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseGroupResponse> ListGroupsAsync(string id, string name, string type, string nameLike, string member, string potentialStarter, Sort? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (type != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("type") + "=").Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (member != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("member") + "=").Append(System.Uri.EscapeDataString(ConvertToString(member, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (potentialStarter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("potentialStarter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(potentialStarter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseGroupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupResponse> CreateGroupAsync(GroupRequest body)
        {
            return CreateGroupAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupResponse> CreateGroupAsync(GroupRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the group was created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the id of the group was missing.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single group</summary>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupResponse> GetGroupAsync(string groupId)
        {
            return GetGroupAsync(groupId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single group</summary>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupResponse> GetGroupAsync(string groupId, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups/{groupId}");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested group does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a group</summary>
        /// <returns>Indicates the group was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupResponse> UpdateGroupAsync(string groupId, GroupRequest body)
        {
            return UpdateGroupAsync(groupId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a group</summary>
        /// <returns>Indicates the group was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupResponse> UpdateGroupAsync(string groupId, GroupRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups/{groupId}");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested group was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested group was updated simultaneously.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a group</summary>
        /// <returns>Indicates the group was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteGroupAsync(string groupId)
        {
            return DeleteGroupAsync(groupId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a group</summary>
        /// <returns>Indicates the group was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteGroupAsync(string groupId, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups/{groupId}");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested group does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Add a member to a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<MembershipResponse> CreateMembershipAsync(string groupId, MembershipRequest body)
        {
            return CreateMembershipAsync(groupId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a member to a group</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<MembershipResponse> CreateMembershipAsync(string groupId, MembershipRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups/{groupId}/members");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<MembershipResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the group was found and the member has been added.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the userId was not included in the request body.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested group was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user is already a member of the group.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a member from a group</summary>
        /// <returns>Indicates the group was found and the member has been deleted. The response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteMembershipAsync(string groupId, string userId)
        {
            return DeleteMembershipAsync(groupId, userId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a member from a group</summary>
        /// <returns>Indicates the group was found and the member has been deleted. The response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteMembershipAsync(string groupId, string userId, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");

            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/groups/{groupId}/members/{userId}");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested group was not found or that the user is not a member of the group. The status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List users</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="firstName">Only return users with the given firstname</param>
        /// <param name="lastName">Only return users with the given lastname</param>
        /// <param name="displayName">Only return users with the given displayName</param>
        /// <param name="email">Only return users with the given email</param>
        /// <param name="firstNameLike">Only return userswith a firstname like the given value. Use % as wildcard-character.</param>
        /// <param name="lastNameLike">Only return users with a lastname like the given value. Use % as wildcard-character.</param>
        /// <param name="displayNameLike">Only return users with a displayName like the given value. Use % as wildcard-character.</param>
        /// <param name="emailLike">Only return users with an email like the given value. Use % as wildcard-character.</param>
        /// <param name="memberOfGroup">Only return users which are a member of the given group.</param>
        /// <param name="tenantId">Only return users which are a members of the given tenant.</param>
        /// <param name="potentialStarter">Only return users  which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseUserResponse> ListUsersAsync(string id, string firstName, string lastName, string displayName, string email, string firstNameLike, string lastNameLike, string displayNameLike, string emailLike, string memberOfGroup, string tenantId, string potentialStarter, Sort2? sort)
        {
            return ListUsersAsync(id, firstName, lastName, displayName, email, firstNameLike, lastNameLike, displayNameLike, emailLike, memberOfGroup, tenantId, potentialStarter, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List users</summary>
        /// <param name="id">Only return group with the given id</param>
        /// <param name="firstName">Only return users with the given firstname</param>
        /// <param name="lastName">Only return users with the given lastname</param>
        /// <param name="displayName">Only return users with the given displayName</param>
        /// <param name="email">Only return users with the given email</param>
        /// <param name="firstNameLike">Only return userswith a firstname like the given value. Use % as wildcard-character.</param>
        /// <param name="lastNameLike">Only return users with a lastname like the given value. Use % as wildcard-character.</param>
        /// <param name="displayNameLike">Only return users with a displayName like the given value. Use % as wildcard-character.</param>
        /// <param name="emailLike">Only return users with an email like the given value. Use % as wildcard-character.</param>
        /// <param name="memberOfGroup">Only return users which are a member of the given group.</param>
        /// <param name="tenantId">Only return users which are a members of the given tenant.</param>
        /// <param name="potentialStarter">Only return users  which members are potential starters for a process-definition with the given id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the group exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseUserResponse> ListUsersAsync(string id, string firstName, string lastName, string displayName, string email, string firstNameLike, string lastNameLike, string displayNameLike, string emailLike, string memberOfGroup, string tenantId, string potentialStarter, Sort2? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (firstName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("firstName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(firstName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (lastName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("lastName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(lastName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (displayName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("displayName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(displayName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (email != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("email") + "=").Append(System.Uri.EscapeDataString(ConvertToString(email, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (firstNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("firstNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(firstNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (lastNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("lastNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(lastNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (displayNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("displayNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(displayNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (emailLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("emailLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(emailLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (memberOfGroup != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("memberOfGroup") + "=").Append(System.Uri.EscapeDataString(ConvertToString(memberOfGroup, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (potentialStarter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("potentialStarter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(potentialStarter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseUserResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a user</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserResponse> CreateUserAsync(UserRequest body)
        {
            return CreateUserAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a user</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UserResponse> CreateUserAsync(UserRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UserResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the user was created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the id of the user was missing.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single user</summary>
        /// <returns>Indicates the user exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserResponse> GetUserAsync(string userId)
        {
            return GetUserAsync(userId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single user</summary>
        /// <returns>Indicates the user exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UserResponse> GetUserAsync(string userId, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UserResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a user</summary>
        /// <returns>Indicates the user was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserResponse> UpdateUserAsync(string userId, UserRequest body)
        {
            return UpdateUserAsync(userId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a user</summary>
        /// <returns>Indicates the user was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UserResponse> UpdateUserAsync(string userId, UserRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UserResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was updated simultaneously.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a user</summary>
        /// <returns>Indicates the user was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteUserAsync(string userId)
        {
            return DeleteUserAsync(userId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a user</summary>
        /// <returns>Indicates the user was found and  has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteUserAsync(string userId, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List user’s info</summary>
        /// <returns>Indicates the user was found and list of info (key and url) is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserInfoResponse>> ListUserInfoAsync(string userId)
        {
            return ListUserInfoAsync(userId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List user’s info</summary>
        /// <returns>Indicates the user was found and list of info (key and url) is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserInfoResponse>> ListUserInfoAsync(string userId, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/info");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<UserInfoResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a new user’s info entry</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserInfoResponse> CreateUserInfoAsync(string userId, UserInfoRequest body)
        {
            return CreateUserInfoAsync(userId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new user’s info entry</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UserInfoResponse> CreateUserInfoAsync(string userId, UserInfoRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/info");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UserInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the user was found and the info has been created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the key or value was missing from the request body. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates there is already an info-entry with the given key for the user, update the resource instance (PUT).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a user’s info</summary>
        /// <returns>Indicates the user was found and the user has info for the given key.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserInfoResponse> GetUserInfoAsync(string userId, string key)
        {
            return GetUserInfoAsync(userId, key, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a user’s info</summary>
        /// <returns>Indicates the user was found and the user has info for the given key.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UserInfoResponse> GetUserInfoAsync(string userId, string key, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            if (key == null)
                throw new System.ArgumentNullException("key");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/info/{key}");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UserInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found or the user does ot have info for the given key. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a user’s info</summary>
        /// <returns>Indicates the user was found and the info has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<UserInfoResponse> UpdateUserInfoAsync(string userId, string key, UserInfoRequest body)
        {
            return UpdateUserInfoAsync(userId, key, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a user’s info</summary>
        /// <returns>Indicates the user was found and the info has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UserInfoResponse> UpdateUserInfoAsync(string userId, string key, UserInfoRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            if (key == null)
                throw new System.ArgumentNullException("key");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/info/{key}");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UserInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the value was missing from the request body.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found or the user does not have info for the given key. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a user’s info</summary>
        /// <returns>Indicates the user was found and the info for the given key has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteUserInfoAsync(string userId, string key)
        {
            return DeleteUserInfoAsync(userId, key, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a user’s info</summary>
        /// <returns>Indicates the user was found and the info for the given key has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteUserInfoAsync(string userId, string key, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            if (key == null)
                throw new System.ArgumentNullException("key");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/info/{key}");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found or the user does not have info for the given key. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a user’s picture</summary>
        /// <returns>Indicates the user was found and has a picture, which is returned in the body.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetUserPictureAsync(string userId)
        {
            return GetUserPictureAsync(userId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a user’s picture</summary>
        /// <returns>Indicates the user was found and has a picture, which is returned in the body.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetUserPictureAsync(string userId, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/picture");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found or the user does not have a profile picture. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Updating a user’s picture</summary>
        /// <param name="file">Picture to update</param>
        /// <returns>Indicates the user was found and the picture has been updated. The response-body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UpdateUserPictureAsync(string userId, FileParameter file)
        {
            return UpdateUserPictureAsync(userId, file, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Updating a user’s picture</summary>
        /// <param name="file">Picture to update</param>
        /// <returns>Indicates the user was found and the picture has been updated. The response-body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task UpdateUserPictureAsync(string userId, FileParameter file, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("identity/users/{userId}/picture");
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (file == null)
                        throw new System.ArgumentNullException("file");
                    else
                    {
                        var content_file_ = new System.Net.Http.StreamContent(file.Data);
                        if (!string.IsNullOrEmpty(file.ContentType))
                            content_file_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(file.ContentType);
                        content_.Add(content_file_, "file", file.FileName ?? "file");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested user was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single batch part</summary>
        /// <returns>Indicates the batch part exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<BatchPartResponse> GetBatchPartAsync(string batchPartId)
        {
            return GetBatchPartAsync(batchPartId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single batch part</summary>
        /// <returns>Indicates the batch part exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<BatchPartResponse> GetBatchPartAsync(string batchPartId, System.Threading.CancellationToken cancellationToken)
        {
            if (batchPartId == null)
                throw new System.ArgumentNullException("batchPartId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batch-parts/{batchPartId}");
            urlBuilder_.Replace("{batchPartId}", System.Uri.EscapeDataString(ConvertToString(batchPartId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BatchPartResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested batch part does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the batch part document</summary>
        /// <returns>Indicates the requested batch part was found and the batch part document has been returned. The response contains the raw batch part document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetBatchPartDocumentAsync(string batchPartId)
        {
            return GetBatchPartDocumentAsync(batchPartId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the batch part document</summary>
        /// <returns>Indicates the requested batch part was found and the batch part document has been returned. The response contains the raw batch part document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetBatchPartDocumentAsync(string batchPartId, System.Threading.CancellationToken cancellationToken)
        {
            if (batchPartId == null)
                throw new System.ArgumentNullException("batchPartId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batch-parts/{batchPartId}/batch-part-document");
            urlBuilder_.Replace("{batchPartId}", System.Uri.EscapeDataString(ConvertToString(batchPartId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested batch part was not found or the job does not have a batch part document. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List batches</summary>
        /// <param name="id">Only return batch with the given id</param>
        /// <param name="batchType">Only return batches for the given type</param>
        /// <param name="searchKey">Only return batches for the given search key</param>
        /// <param name="searchKey2">Only return batches for the given search key2</param>
        /// <param name="createTimeBefore">Only return batches created before the given date</param>
        /// <param name="createTimeAfter">Only batches batches created after the given date</param>
        /// <param name="completeTimeBefore">Only return batches completed before the given date</param>
        /// <param name="completeTimeAfter">Only batches batches completed after the given date</param>
        /// <param name="status">Only return batches for the given status</param>
        /// <param name="tenantId">Only return batches for the given tenant id</param>
        /// <param name="tenantIdLike">Only return batches like given search key</param>
        /// <param name="withoutTenantId">If true, only returns batches without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates the requested batches were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseBatchResponse> ListBatchesAsync(string id, string batchType, string searchKey, string searchKey2, System.DateTimeOffset? createTimeBefore, System.DateTimeOffset? createTimeAfter, System.DateTimeOffset? completeTimeBefore, System.DateTimeOffset? completeTimeAfter, string status, string tenantId, string tenantIdLike, bool? withoutTenantId)
        {
            return ListBatchesAsync(id, batchType, searchKey, searchKey2, createTimeBefore, createTimeAfter, completeTimeBefore, completeTimeAfter, status, tenantId, tenantIdLike, withoutTenantId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List batches</summary>
        /// <param name="id">Only return batch with the given id</param>
        /// <param name="batchType">Only return batches for the given type</param>
        /// <param name="searchKey">Only return batches for the given search key</param>
        /// <param name="searchKey2">Only return batches for the given search key2</param>
        /// <param name="createTimeBefore">Only return batches created before the given date</param>
        /// <param name="createTimeAfter">Only batches batches created after the given date</param>
        /// <param name="completeTimeBefore">Only return batches completed before the given date</param>
        /// <param name="completeTimeAfter">Only batches batches completed after the given date</param>
        /// <param name="status">Only return batches for the given status</param>
        /// <param name="tenantId">Only return batches for the given tenant id</param>
        /// <param name="tenantIdLike">Only return batches like given search key</param>
        /// <param name="withoutTenantId">If true, only returns batches without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <returns>Indicates the requested batches were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseBatchResponse> ListBatchesAsync(string id, string batchType, string searchKey, string searchKey2, System.DateTimeOffset? createTimeBefore, System.DateTimeOffset? createTimeAfter, System.DateTimeOffset? completeTimeBefore, System.DateTimeOffset? completeTimeAfter, string status, string tenantId, string tenantIdLike, bool? withoutTenantId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batches?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (batchType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("batchType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(batchType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (searchKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("searchKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(searchKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (searchKey2 != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("searchKey2") + "=").Append(System.Uri.EscapeDataString(ConvertToString(searchKey2, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createTimeBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createTimeBefore") + "=").Append(System.Uri.EscapeDataString(createTimeBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createTimeAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createTimeAfter") + "=").Append(System.Uri.EscapeDataString(createTimeAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (completeTimeBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("completeTimeBefore") + "=").Append(System.Uri.EscapeDataString(completeTimeBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (completeTimeAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("completeTimeAfter") + "=").Append(System.Uri.EscapeDataString(completeTimeAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (status != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("status") + "=").Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseBatchResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single batch</summary>
        /// <returns>Indicates the batch exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<BatchResponse> GetBatchAsync(string batchId)
        {
            return GetBatchAsync(batchId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single batch</summary>
        /// <returns>Indicates the batch exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<BatchResponse> GetBatchAsync(string batchId, System.Threading.CancellationToken cancellationToken)
        {
            if (batchId == null)
                throw new System.ArgumentNullException("batchId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batches/{batchId}");
            urlBuilder_.Replace("{batchId}", System.Uri.EscapeDataString(ConvertToString(batchId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BatchResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested batch does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a batch</summary>
        /// <returns>Indicates the batch was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteBatchAsync(string batchId)
        {
            return DeleteBatchAsync(batchId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a batch</summary>
        /// <returns>Indicates the batch was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteBatchAsync(string batchId, System.Threading.CancellationToken cancellationToken)
        {
            if (batchId == null)
                throw new System.ArgumentNullException("batchId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batches/{batchId}");
            urlBuilder_.Replace("{batchId}", System.Uri.EscapeDataString(ConvertToString(batchId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested batch was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the batch document</summary>
        /// <returns>Indicates the requested batch was found and the batch document has been returned. The response contains the raw batch document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetBatchDocumentAsync(string batchId)
        {
            return GetBatchDocumentAsync(batchId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the batch document</summary>
        /// <returns>Indicates the requested batch was found and the batch document has been returned. The response contains the raw batch document and always has a Content-type of application/json.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetBatchDocumentAsync(string batchId, System.Threading.CancellationToken cancellationToken)
        {
            if (batchId == null)
                throw new System.ArgumentNullException("batchId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batches/{batchId}/batch-document");
            urlBuilder_.Replace("{batchId}", System.Uri.EscapeDataString(ConvertToString(batchId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested batch was not found or the job does not have a batch document. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List batch parts</summary>
        /// <param name="status">Only return batch parts for the given status</param>
        /// <returns>Indicates the requested batch parts were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchPartResponse>> ListBatchesPartAsync(string batchId, string status)
        {
            return ListBatchesPartAsync(batchId, status, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List batch parts</summary>
        /// <param name="status">Only return batch parts for the given status</param>
        /// <returns>Indicates the requested batch parts were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchPartResponse>> ListBatchesPartAsync(string batchId, string status, System.Threading.CancellationToken cancellationToken)
        {
            if (batchId == null)
                throw new System.ArgumentNullException("batchId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/batches/{batchId}/batch-parts?");
            urlBuilder_.Replace("{batchId}", System.Uri.EscapeDataString(ConvertToString(batchId, System.Globalization.CultureInfo.InvariantCulture)));
            if (status != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("status") + "=").Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<BatchPartResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List deadletter jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseJobResponse> ListDeadLetterJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort3? sort)
        {
            return ListDeadLetterJobsAsync(id, processInstanceId, executionId, processDefinitionId, elementId, elementName, executable, timersOnly, messagesOnly, withException, dueBefore, dueAfter, exceptionMessage, tenantId, tenantIdLike, withoutTenantId, locked, unlocked, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List deadletter jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseJobResponse> ListDeadLetterJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort3? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/deadletter-jobs?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executable != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executable") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executable, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (timersOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timersOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timersOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messagesOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messagesOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messagesOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withException != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withException") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withException, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueBefore") + "=").Append(System.Uri.EscapeDataString(dueBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueAfter") + "=").Append(System.Uri.EscapeDataString(dueAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (exceptionMessage != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("exceptionMessage") + "=").Append(System.Uri.EscapeDataString(ConvertToString(exceptionMessage, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (locked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("locked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(locked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (unlocked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("unlocked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(unlocked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseJobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter or the both \'messagesOnly\' and \'timersOnly\' are used as parameters. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single deadletter job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<JobResponse> GetDeadletterJobAsync(string jobId)
        {
            return GetDeadletterJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single deadletter job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<JobResponse> GetDeadletterJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/deadletter-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<JobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Move a single deadletter job</summary>
        /// <returns>Indicates the dead letter job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ExecuteDeadLetterJobActionAsync(string jobId, RestActionRequest body)
        {
            return ExecuteDeadLetterJobActionAsync(jobId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Move a single deadletter job</summary>
        /// <returns>Indicates the dead letter job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ExecuteDeadLetterJobActionAsync(string jobId, RestActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/deadletter-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the an exception occurred while executing the job. The status-description contains additional detail about the error. The full error-stacktrace can be fetched later on if needed.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a deadletter job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteDeadLetterJobAsync(string jobId)
        {
            return DeleteDeadLetterJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a deadletter job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteDeadLetterJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/deadletter-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the exception stacktrace for a deadletter job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetDeadLetterJobStacktraceAsync(string jobId)
        {
            return GetDeadLetterJobStacktraceAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a deadletter job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetDeadLetterJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/deadletter-jobs/{jobId}/exception-stacktrace");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found or the job does not have an exception stacktrace. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get engine info</summary>
        /// <returns>Indicates the engine info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessEngineInfoResponse> GetEngineInfoAsync()
        {
            return GetEngineInfoAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get engine info</summary>
        /// <returns>Indicates the engine info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessEngineInfoResponse> GetEngineInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/engine");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessEngineInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseJobResponse> ListJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort4? sort)
        {
            return ListJobsAsync(id, processInstanceId, executionId, processDefinitionId, elementId, elementName, timersOnly, messagesOnly, withException, dueBefore, dueAfter, exceptionMessage, tenantId, tenantIdLike, withoutTenantId, locked, unlocked, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseJobResponse> ListJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort4? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/jobs?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (timersOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timersOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timersOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messagesOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messagesOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messagesOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withException != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withException") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withException, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueBefore") + "=").Append(System.Uri.EscapeDataString(dueBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueAfter") + "=").Append(System.Uri.EscapeDataString(dueAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (exceptionMessage != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("exceptionMessage") + "=").Append(System.Uri.EscapeDataString(ConvertToString(exceptionMessage, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (locked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("locked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(locked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (unlocked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("unlocked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(unlocked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseJobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter or the both \'messagesOnly\' and \'timersOnly\' are used as parameters. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single job</summary>
        /// <returns>Indicates the job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<JobResponse> GetJobAsync(string jobId)
        {
            return GetJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single job</summary>
        /// <returns>Indicates the job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<JobResponse> GetJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<JobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Execute a single job</summary>
        /// <returns>Indicates the job was executed. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ExecuteJobActionAsync(string jobId, RestActionRequest body)
        {
            return ExecuteJobActionAsync(jobId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute a single job</summary>
        /// <returns>Indicates the job was executed. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ExecuteJobActionAsync(string jobId, RestActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the an exception occurred while executing the job. The status-description contains additional detail about the error. The full error-stacktrace can be fetched later on if needed.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteJobAsync(string jobId)
        {
            return DeleteJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found..", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the exception stacktrace for a job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetJobStacktraceAsync(string jobId)
        {
            return GetJobStacktraceAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/jobs/{jobId}/exception-stacktrace");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found or the job does not have an exception stacktrace. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List engine properties</summary>
        /// <returns>Indicates the properties are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> GetPropertiesAsync()
        {
            return GetPropertiesAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List engine properties</summary>
        /// <returns>Indicates the properties are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> GetPropertiesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/properties");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List suspended jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseJobResponse> ListSuspendedJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort5? sort)
        {
            return ListSuspendedJobsAsync(id, processInstanceId, executionId, processDefinitionId, elementId, elementName, executable, timersOnly, messagesOnly, withException, dueBefore, dueAfter, exceptionMessage, tenantId, tenantIdLike, withoutTenantId, locked, unlocked, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List suspended jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseJobResponse> ListSuspendedJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort5? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/suspended-jobs?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executable != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executable") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executable, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (timersOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timersOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timersOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messagesOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messagesOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messagesOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withException != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withException") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withException, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueBefore") + "=").Append(System.Uri.EscapeDataString(dueBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueAfter") + "=").Append(System.Uri.EscapeDataString(dueAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (exceptionMessage != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("exceptionMessage") + "=").Append(System.Uri.EscapeDataString(ConvertToString(exceptionMessage, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (locked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("locked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(locked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (unlocked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("unlocked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(unlocked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseJobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter or the both \'messagesOnly\' and \'timersOnly\' are used as parameters. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single suspended job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<JobResponse> GetSuspendedJobAsync(string jobId)
        {
            return GetSuspendedJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single suspended job</summary>
        /// <returns>Indicates the suspended job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<JobResponse> GetSuspendedJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/suspended-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<JobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a suspended job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSuspendedJobAsync(string jobId)
        {
            return DeleteSuspendedJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a suspended job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSuspendedJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/suspended-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the exception stacktrace for a suspended job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetSuspendedJobStacktraceAsync(string jobId)
        {
            return GetSuspendedJobStacktraceAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a suspended job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetSuspendedJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/suspended-jobs/{jobId}/exception-stacktrace");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found or the job does not have an exception stacktrace. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List tables</summary>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TableResponse>> ListTablesAsync()
        {
            return ListTablesAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List tables</summary>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TableResponse>> ListTablesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/tables");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<TableResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single table</summary>
        /// <returns>Indicates the table exists and the table count is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TableResponse> GetTableAsync(string tableName)
        {
            return GetTableAsync(tableName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single table</summary>
        /// <returns>Indicates the table exists and the table count is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TableResponse> GetTableAsync(string tableName, System.Threading.CancellationToken cancellationToken)
        {
            if (tableName == null)
                throw new System.ArgumentNullException("tableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/tables/{tableName}");
            urlBuilder_.Replace("{tableName}", System.Uri.EscapeDataString(ConvertToString(tableName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TableResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested table does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get column info for a single table</summary>
        /// <returns>Indicates the table exists and the table column info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TableMetaData> GetTableMetaDataAsync(string tableName)
        {
            return GetTableMetaDataAsync(tableName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get column info for a single table</summary>
        /// <returns>Indicates the table exists and the table column info is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TableMetaData> GetTableMetaDataAsync(string tableName, System.Threading.CancellationToken cancellationToken)
        {
            if (tableName == null)
                throw new System.ArgumentNullException("tableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/tables/{tableName}/columns");
            urlBuilder_.Replace("{tableName}", System.Uri.EscapeDataString(ConvertToString(tableName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TableMetaData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested table does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get row data for a single table</summary>
        /// <param name="start">Index of the first row to fetch. Defaults to 0.</param>
        /// <param name="size">Number of rows to fetch, starting from start. Defaults to 10.</param>
        /// <param name="orderAscendingColumn">Name of the column to sort the resulting rows on, ascending.</param>
        /// <param name="orderDescendingColumn">Name of the column to sort the resulting rows on, descending.</param>
        /// <returns>Indicates the table exists and the table row data is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseListMapStringObject> GetTableDataAsync(string tableName, int? start, int? size, string orderAscendingColumn, string orderDescendingColumn)
        {
            return GetTableDataAsync(tableName, start, size, orderAscendingColumn, orderDescendingColumn, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get row data for a single table</summary>
        /// <param name="start">Index of the first row to fetch. Defaults to 0.</param>
        /// <param name="size">Number of rows to fetch, starting from start. Defaults to 10.</param>
        /// <param name="orderAscendingColumn">Name of the column to sort the resulting rows on, ascending.</param>
        /// <param name="orderDescendingColumn">Name of the column to sort the resulting rows on, descending.</param>
        /// <returns>Indicates the table exists and the table row data is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseListMapStringObject> GetTableDataAsync(string tableName, int? start, int? size, string orderAscendingColumn, string orderDescendingColumn, System.Threading.CancellationToken cancellationToken)
        {
            if (tableName == null)
                throw new System.ArgumentNullException("tableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/tables/{tableName}/data?");
            urlBuilder_.Replace("{tableName}", System.Uri.EscapeDataString(ConvertToString(tableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (start != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("start") + "=").Append(System.Uri.EscapeDataString(ConvertToString(start, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (size != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("size") + "=").Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderAscendingColumn != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("orderAscendingColumn") + "=").Append(System.Uri.EscapeDataString(ConvertToString(orderAscendingColumn, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderDescendingColumn != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("orderDescendingColumn") + "=").Append(System.Uri.EscapeDataString(ConvertToString(orderDescendingColumn, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseListMapStringObject>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested table does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List timer jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseJobResponse> ListTimerJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort6? sort)
        {
            return ListTimerJobsAsync(id, processInstanceId, executionId, processDefinitionId, elementId, elementName, executable, timersOnly, messagesOnly, withException, dueBefore, dueAfter, exceptionMessage, tenantId, tenantIdLike, withoutTenantId, locked, unlocked, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List timer jobs</summary>
        /// <param name="id">Only return job with the given id</param>
        /// <param name="processInstanceId">Only return jobs part of a process with the given id</param>
        /// <param name="executionId">Only return jobs part of an execution with the given id</param>
        /// <param name="processDefinitionId">Only return jobs with the given process definition id</param>
        /// <param name="elementId">Only return jobs with the given element id</param>
        /// <param name="elementName">Only return jobs with the given element name</param>
        /// <param name="executable">If true, only return jobs which are executable. If false, this parameter is ignored.</param>
        /// <param name="timersOnly">If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with 'messagesOnly'.</param>
        /// <param name="messagesOnly">If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with 'timersOnly'</param>
        /// <param name="withException">If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.</param>
        /// <param name="dueBefore">Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="dueAfter">Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.</param>
        /// <param name="exceptionMessage">Only return jobs with the given exception message</param>
        /// <param name="tenantId">Only return jobs with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return jobs with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="locked">If true, only return jobs which are locked.  If false, this parameter is ignored.</param>
        /// <param name="unlocked">If true, only return jobs which are unlocked. If false, this parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested jobs were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseJobResponse> ListTimerJobsAsync(string id, string processInstanceId, string executionId, string processDefinitionId, string elementId, string elementName, bool? executable, bool? timersOnly, bool? messagesOnly, bool? withException, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, string exceptionMessage, string tenantId, string tenantIdLike, bool? withoutTenantId, bool? locked, bool? unlocked, Sort6? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/timer-jobs?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (elementName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("elementName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(elementName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executable != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executable") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executable, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (timersOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timersOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timersOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messagesOnly != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messagesOnly") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messagesOnly, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withException != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withException") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withException, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueBefore") + "=").Append(System.Uri.EscapeDataString(dueBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueAfter") + "=").Append(System.Uri.EscapeDataString(dueAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (exceptionMessage != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("exceptionMessage") + "=").Append(System.Uri.EscapeDataString(ConvertToString(exceptionMessage, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (locked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("locked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(locked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (unlocked != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("unlocked") + "=").Append(System.Uri.EscapeDataString(ConvertToString(unlocked, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseJobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter or the both \'messagesOnly\' and \'timersOnly\' are used as parameters. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single timer job</summary>
        /// <returns>Indicates the timer job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<JobResponse> GetTimerJobAsync(string jobId)
        {
            return GetTimerJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single timer job</summary>
        /// <returns>Indicates the timer job exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<JobResponse> GetTimerJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/timer-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<JobResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Move a single timer job</summary>
        /// <returns>Indicates the timer job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ExecuteTimerJobActionAsync(string jobId, RestActionRequest body)
        {
            return ExecuteTimerJobActionAsync(jobId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Move a single timer job</summary>
        /// <returns>Indicates the timer job was moved. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ExecuteTimerJobActionAsync(string jobId, RestActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/timer-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the an exception occurred while executing the job. The status-description contains additional detail about the error. The full error-stacktrace can be fetched later on if needed.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a timer job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTimerJobAsync(string jobId)
        {
            return DeleteTimerJobAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a timer job</summary>
        /// <returns>Indicates the job was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTimerJobAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/timer-jobs/{jobId}");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the exception stacktrace for a timer job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetTimerJobStacktraceAsync(string jobId)
        {
            return GetTimerJobStacktraceAsync(jobId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the exception stacktrace for a timer job</summary>
        /// <returns>Indicates the requested job was not found and the stacktrace has been returned. The response contains the raw stacktrace and always has a Content-type of text/plain.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetTimerJobStacktraceAsync(string jobId, System.Threading.CancellationToken cancellationToken)
        {
            if (jobId == null)
                throw new System.ArgumentNullException("jobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("management/timer-jobs/{jobId}/exception-stacktrace");
            urlBuilder_.Replace("{jobId}", System.Uri.EscapeDataString(ConvertToString(jobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested job was not found or the job does not have an exception stacktrace. Status-description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query executions</summary>
        /// <returns>Indicates request was successful and the executions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseExecutionResponse> QueryExecutionsAsync(ExecutionQueryRequest body)
        {
            return QueryExecutionsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query executions</summary>
        /// <returns>Indicates request was successful and the executions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseExecutionResponse> QueryExecutionsAsync(ExecutionQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/executions");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseExecutionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format . The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query for historic activity instances</summary>
        /// <returns>Indicates request was successful and the activities are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> QueryActivityInstancesAsync(HistoricActivityInstanceQueryRequest body)
        {
            return QueryActivityInstancesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic activity instances</summary>
        /// <returns>Indicates request was successful and the activities are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricActivityInstanceResponse> QueryActivityInstancesAsync(HistoricActivityInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/historic-activity-instances");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricActivityInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query for historic details</summary>
        /// <returns>Indicates request was successful and the historic details are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> QueryHistoricDetailAsync(HistoricDetailQueryRequest body)
        {
            return QueryHistoricDetailAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic details</summary>
        /// <returns>Indicates request was successful and the historic details are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricDetailResponse> QueryHistoricDetailAsync(HistoricDetailQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/historic-detail");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricDetailResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query for historic process instances</summary>
        /// <returns>Indicates request was successful and the process instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> QueryHistoricProcessInstanceAsync(HistoricProcessInstanceQueryRequest body)
        {
            return QueryHistoricProcessInstanceAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic process instances</summary>
        /// <returns>Indicates request was successful and the process instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricProcessInstanceResponse> QueryHistoricProcessInstanceAsync(HistoricProcessInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/historic-process-instances");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query for historic task instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> QueryHistoricTaskInstanceAsync(HistoricTaskInstanceQueryRequest body)
        {
            return QueryHistoricTaskInstanceAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic task instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricTaskInstanceResponse> QueryHistoricTaskInstanceAsync(HistoricTaskInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/historic-task-instances");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricTaskInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query for historic variable instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> QueryVariableInstancesAsync(HistoricVariableInstanceQueryRequest body)
        {
            return QueryVariableInstancesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for historic variable instances</summary>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseHistoricVariableInstanceResponse> QueryVariableInstancesAsync(HistoricVariableInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/historic-variable-instances");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseHistoricVariableInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query process instances</summary>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> QueryProcessInstancesAsync(ProcessInstanceQueryRequest body)
        {
            return QueryProcessInstancesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query process instances</summary>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> QueryProcessInstancesAsync(ProcessInstanceQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/process-instances");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format . The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Query for tasks</summary>
        /// <returns>Indicates request was successful and the tasks are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseTaskResponse> QueryTasksAsync(TaskQueryRequest body)
        {
            return QueryTasksAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Query for tasks</summary>
        /// <returns>Indicates request was successful and the tasks are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseTaskResponse> QueryTasksAsync(TaskQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("query/tasks");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format or that delegationState has an invalid value (other than pending and resolved). The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List Deployments</summary>
        /// <param name="name">Only return deployments with the given name.</param>
        /// <param name="nameLike">Only return deployments with a name like the given name.</param>
        /// <param name="category">Only return deployments with the given category.</param>
        /// <param name="categoryNotEquals">Only return deployments which do not have the given category.</param>
        /// <param name="parentDeploymentId">Only return deployments with the given parent deployment id.</param>
        /// <param name="parentDeploymentIdLike">Only return deployments with a parent deployment id like the given value.</param>
        /// <param name="tenantId">Only return deployments with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return deployments with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns deployments without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseDeploymentResponse> ListDeploymentsAsync(string name, string nameLike, string category, string categoryNotEquals, string parentDeploymentId, string parentDeploymentIdLike, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort7? sort)
        {
            return ListDeploymentsAsync(name, nameLike, category, categoryNotEquals, parentDeploymentId, parentDeploymentIdLike, tenantId, tenantIdLike, withoutTenantId, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List Deployments</summary>
        /// <param name="name">Only return deployments with the given name.</param>
        /// <param name="nameLike">Only return deployments with a name like the given name.</param>
        /// <param name="category">Only return deployments with the given category.</param>
        /// <param name="categoryNotEquals">Only return deployments which do not have the given category.</param>
        /// <param name="parentDeploymentId">Only return deployments with the given parent deployment id.</param>
        /// <param name="parentDeploymentIdLike">Only return deployments with a parent deployment id like the given value.</param>
        /// <param name="tenantId">Only return deployments with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return deployments with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns deployments without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the request was successful.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseDeploymentResponse> ListDeploymentsAsync(string name, string nameLike, string category, string categoryNotEquals, string parentDeploymentId, string parentDeploymentIdLike, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort7? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments?");
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (category != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("category") + "=").Append(System.Uri.EscapeDataString(ConvertToString(category, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (categoryNotEquals != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("categoryNotEquals") + "=").Append(System.Uri.EscapeDataString(ConvertToString(categoryNotEquals, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (parentDeploymentId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("parentDeploymentId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(parentDeploymentId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (parentDeploymentIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("parentDeploymentIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(parentDeploymentIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseDeploymentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a new deployment</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeploymentResponse> UploadDeploymentAsync(string deploymentKey, string deploymentName, string tenantId, FileParameter file)
        {
            return UploadDeploymentAsync(deploymentKey, deploymentName, tenantId, file, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new deployment</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeploymentResponse> UploadDeploymentAsync(string deploymentKey, string deploymentName, string tenantId, FileParameter file, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments?");
            if (deploymentKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deploymentKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deploymentKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deploymentName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deploymentName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deploymentName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (file == null)
                        throw new System.ArgumentNullException("file");
                    else
                    {
                        var content_file_ = new System.Net.Http.StreamContent(file.Data);
                        if (!string.IsNullOrEmpty(file.ContentType))
                            content_file_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(file.ContentType);
                        content_.Add(content_file_, "file", file.FileName ?? "file");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeploymentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the deployment was created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates there was no content present in the request body or the content mime-type is not supported for deployment. The status-description contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a deployment</summary>
        /// <param name="deploymentId">The id of the deployment to get.</param>
        /// <returns>Indicates the deployment was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeploymentResponse> GetDeploymentAsync(string deploymentId)
        {
            return GetDeploymentAsync(deploymentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deployment</summary>
        /// <param name="deploymentId">The id of the deployment to get.</param>
        /// <returns>Indicates the deployment was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeploymentResponse> GetDeploymentAsync(string deploymentId, System.Threading.CancellationToken cancellationToken)
        {
            if (deploymentId == null)
                throw new System.ArgumentNullException("deploymentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments/{deploymentId}");
            urlBuilder_.Replace("{deploymentId}", System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeploymentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested deployment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a deployment</summary>
        /// <returns>Indicates the deployment was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteDeploymentAsync(string deploymentId, bool? cascade)
        {
            return DeleteDeploymentAsync(deploymentId, cascade, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a deployment</summary>
        /// <returns>Indicates the deployment was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteDeploymentAsync(string deploymentId, bool? cascade, System.Threading.CancellationToken cancellationToken)
        {
            if (deploymentId == null)
                throw new System.ArgumentNullException("deploymentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments/{deploymentId}?");
            urlBuilder_.Replace("{deploymentId}", System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture)));
            if (cascade != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("cascade") + "=").Append(System.Uri.EscapeDataString(ConvertToString(cascade, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested deployment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a deployment resource content</summary>
        /// <param name="resourceName">The name of the resource to get. Make sure you URL-encode the resourceName in case it contains forward slashes. Eg: use diagrams%2Fmy-process.bpmn20.xml instead of diagrams/my-process.bpmn20.xml.</param>
        /// <returns>Indicates both deployment and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetDeploymentResourceDataAsync(string deploymentId, string resourceName)
        {
            return GetDeploymentResourceDataAsync(deploymentId, resourceName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deployment resource content</summary>
        /// <param name="resourceName">The name of the resource to get. Make sure you URL-encode the resourceName in case it contains forward slashes. Eg: use diagrams%2Fmy-process.bpmn20.xml instead of diagrams/my-process.bpmn20.xml.</param>
        /// <returns>Indicates both deployment and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetDeploymentResourceDataAsync(string deploymentId, string resourceName, System.Threading.CancellationToken cancellationToken)
        {
            if (deploymentId == null)
                throw new System.ArgumentNullException("deploymentId");

            if (resourceName == null)
                throw new System.ArgumentNullException("resourceName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments/{deploymentId}/resourcedata/{resourceName}");
            urlBuilder_.Replace("{deploymentId}", System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{resourceName}", System.Uri.EscapeDataString(ConvertToString(resourceName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested deployment was not found or there is no resource with the given id present in the deployment. The status-description contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List resources in a deployment</summary>
        /// <returns>Indicates the deployment was found and the resource list has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DeploymentResourceResponse>> ListDeploymentResourcesAsync(string deploymentId)
        {
            return ListDeploymentResourcesAsync(deploymentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List resources in a deployment</summary>
        /// <returns>Indicates the deployment was found and the resource list has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DeploymentResourceResponse>> ListDeploymentResourcesAsync(string deploymentId, System.Threading.CancellationToken cancellationToken)
        {
            if (deploymentId == null)
                throw new System.ArgumentNullException("deploymentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments/{deploymentId}/resources");
            urlBuilder_.Replace("{deploymentId}", System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<DeploymentResourceResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested deployment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a deployment resource</summary>
        /// <returns>Indicates both deployment and resource have been found and the resource has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeploymentResourceResponse> GetDeploymentResourceAsync(string deploymentId)
        {
            return GetDeploymentResourceAsync(deploymentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deployment resource</summary>
        /// <returns>Indicates both deployment and resource have been found and the resource has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeploymentResourceResponse> GetDeploymentResourceAsync(string deploymentId, System.Threading.CancellationToken cancellationToken)
        {
            if (deploymentId == null)
                throw new System.ArgumentNullException("deploymentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/deployments/{deploymentId}/resources/**");
            urlBuilder_.Replace("{deploymentId}", System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeploymentResourceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested deployment was not found or there is no resource with the given id present in the deployment. The status-description contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List models</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="category">Only return models with the given category.</param>
        /// <param name="categoryLike">Only return models with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return models which do not have the given category.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models with a name like the given name.</param>
        /// <param name="key">Only return models with the given key.</param>
        /// <param name="deploymentId">Only return models with the given category.</param>
        /// <param name="version">Only return models with the given version.</param>
        /// <param name="latestVersion">If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned.</param>
        /// <param name="deployed">If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null).</param>
        /// <param name="tenantId">Only return models with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return models with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the models are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseModelResponse> ListModelsAsync(string id, string category, string categoryLike, string categoryNotEquals, string name, string nameLike, string key, string deploymentId, int? version, bool? latestVersion, bool? deployed, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort8? sort)
        {
            return ListModelsAsync(id, category, categoryLike, categoryNotEquals, name, nameLike, key, deploymentId, version, latestVersion, deployed, tenantId, tenantIdLike, withoutTenantId, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List models</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="category">Only return models with the given category.</param>
        /// <param name="categoryLike">Only return models with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return models which do not have the given category.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models with a name like the given name.</param>
        /// <param name="key">Only return models with the given key.</param>
        /// <param name="deploymentId">Only return models with the given category.</param>
        /// <param name="version">Only return models with the given version.</param>
        /// <param name="latestVersion">If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned.</param>
        /// <param name="deployed">If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null).</param>
        /// <param name="tenantId">Only return models with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return models with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the models are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseModelResponse> ListModelsAsync(string id, string category, string categoryLike, string categoryNotEquals, string name, string nameLike, string key, string deploymentId, int? version, bool? latestVersion, bool? deployed, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort8? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (category != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("category") + "=").Append(System.Uri.EscapeDataString(ConvertToString(category, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (categoryLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("categoryLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(categoryLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (categoryNotEquals != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("categoryNotEquals") + "=").Append(System.Uri.EscapeDataString(ConvertToString(categoryNotEquals, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (key != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deploymentId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deploymentId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (version != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("version") + "=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (latestVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("latestVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(latestVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deployed != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deployed") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deployed, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseModelResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a model</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ModelResponse> CreateModelAsync(ModelRequest body)
        {
            return CreateModelAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a model</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ModelResponse> CreateModelAsync(ModelRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ModelResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the model was created.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a model</summary>
        /// <returns>Indicates the model was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ModelResponse> GetModelAsync(string modelId)
        {
            return GetModelAsync(modelId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a model</summary>
        /// <returns>Indicates the model was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ModelResponse> GetModelAsync(string modelId, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ModelResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a model</summary>
        /// <returns>Indicates the model was found and updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ModelResponse> UpdateModelAsync(string modelId, ModelRequest body)
        {
            return UpdateModelAsync(modelId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a model</summary>
        /// <returns>Indicates the model was found and updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ModelResponse> UpdateModelAsync(string modelId, ModelRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ModelResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a model</summary>
        /// <returns>Indicates the model was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteModelAsync(string modelId)
        {
            return DeleteModelAsync(modelId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a model</summary>
        /// <returns>Indicates the model was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteModelAsync(string modelId, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelBytesAsync(string modelId)
        {
            return GetModelBytesAsync(modelId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelBytesAsync(string modelId, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}/source");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Set the editor source for a model</summary>
        /// <returns>Indicates the model was found and the source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task SetModelSourceAsync(string modelId, FileParameter file)
        {
            return SetModelSourceAsync(modelId, file, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Set the editor source for a model</summary>
        /// <returns>Indicates the model was found and the source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task SetModelSourceAsync(string modelId, FileParameter file, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}/source");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (file == null)
                        throw new System.ArgumentNullException("file");
                    else
                    {
                        var content_file_ = new System.Net.Http.StreamContent(file.Data);
                        if (!string.IsNullOrEmpty(file.ContentType))
                            content_file_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(file.ContentType);
                        content_.Add(content_file_, "file", file.FileName ?? "file");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExtraEditorSourceAsync(string modelId)
        {
            return GetExtraEditorSourceAsync(modelId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and source is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExtraEditorSourceAsync(string modelId, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}/source-extra");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Set the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and the extra source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task SetExtraEditorSourceAsync(string modelId, FileParameter file)
        {
            return SetExtraEditorSourceAsync(modelId, file, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Set the extra editor source for a model</summary>
        /// <returns>Indicates the model was found and the extra source has been updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task SetExtraEditorSourceAsync(string modelId, FileParameter file, System.Threading.CancellationToken cancellationToken)
        {
            if (modelId == null)
                throw new System.ArgumentNullException("modelId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/models/{modelId}/source-extra");
            urlBuilder_.Replace("{modelId}", System.Uri.EscapeDataString(ConvertToString(modelId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (file == null)
                        throw new System.ArgumentNullException("file");
                    else
                    {
                        var content_file_ = new System.Net.Http.StreamContent(file.Data);
                        if (!string.IsNullOrEmpty(file.ContentType))
                            content_file_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(file.ContentType);
                        content_.Add(content_file_, "file", file.FileName ?? "file");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested model was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of process definitions</summary>
        /// <param name="version">Only return process definitions with the given version.</param>
        /// <param name="name">Only return process definitions with the given name.</param>
        /// <param name="nameLike">Only return process definitions with a name like the given name.</param>
        /// <param name="key">Only return process definitions with the given key.</param>
        /// <param name="keyLike">Only return process definitions with a name like the given key.</param>
        /// <param name="resourceName">Only return process definitions with the given resource name.</param>
        /// <param name="resourceNameLike">Only return process definitions with a name like the given resource name.</param>
        /// <param name="category">Only return process definitions with the given category.</param>
        /// <param name="categoryLike">Only return process definitions with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return process definitions which do not have the given category.</param>
        /// <param name="deploymentId">Only return process definitions with the given category.</param>
        /// <param name="startableByUser">Only return process definitions which are part of a deployment with the given id.</param>
        /// <param name="latest">Only return the latest process definition versions. Can only be used together with key and keyLike parameters, using any other parameter will result in a 400-response.</param>
        /// <param name="suspended">If true, only returns process definitions which are suspended. If false, only active process definitions (which are not suspended) are returned.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseProcessDefinitionResponse> ListProcessDefinitionsAsync(int? version, string name, string nameLike, string key, string keyLike, string resourceName, string resourceNameLike, string category, string categoryLike, string categoryNotEquals, string deploymentId, string startableByUser, bool? latest, bool? suspended, Sort9? sort)
        {
            return ListProcessDefinitionsAsync(version, name, nameLike, key, keyLike, resourceName, resourceNameLike, category, categoryLike, categoryNotEquals, deploymentId, startableByUser, latest, suspended, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of process definitions</summary>
        /// <param name="version">Only return process definitions with the given version.</param>
        /// <param name="name">Only return process definitions with the given name.</param>
        /// <param name="nameLike">Only return process definitions with a name like the given name.</param>
        /// <param name="key">Only return process definitions with the given key.</param>
        /// <param name="keyLike">Only return process definitions with a name like the given key.</param>
        /// <param name="resourceName">Only return process definitions with the given resource name.</param>
        /// <param name="resourceNameLike">Only return process definitions with a name like the given resource name.</param>
        /// <param name="category">Only return process definitions with the given category.</param>
        /// <param name="categoryLike">Only return process definitions with a category like the given name.</param>
        /// <param name="categoryNotEquals">Only return process definitions which do not have the given category.</param>
        /// <param name="deploymentId">Only return process definitions with the given category.</param>
        /// <param name="startableByUser">Only return process definitions which are part of a deployment with the given id.</param>
        /// <param name="latest">Only return the latest process definition versions. Can only be used together with key and keyLike parameters, using any other parameter will result in a 400-response.</param>
        /// <param name="suspended">If true, only returns process definitions which are suspended. If false, only active process definitions (which are not suspended) are returned.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseProcessDefinitionResponse> ListProcessDefinitionsAsync(int? version, string name, string nameLike, string key, string keyLike, string resourceName, string resourceNameLike, string category, string categoryLike, string categoryNotEquals, string deploymentId, string startableByUser, bool? latest, bool? suspended, Sort9? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions?");
            if (version != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("version") + "=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (key != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (keyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("keyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(keyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (resourceName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("resourceName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(resourceName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (resourceNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("resourceNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(resourceNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (category != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("category") + "=").Append(System.Uri.EscapeDataString(ConvertToString(category, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (categoryLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("categoryLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(categoryLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (categoryNotEquals != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("categoryNotEquals") + "=").Append(System.Uri.EscapeDataString(ConvertToString(categoryNotEquals, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deploymentId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deploymentId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deploymentId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startableByUser != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startableByUser") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startableByUser, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (latest != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("latest") + "=").Append(System.Uri.EscapeDataString(ConvertToString(latest, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (suspended != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("suspended") + "=").Append(System.Uri.EscapeDataString(ConvertToString(suspended, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseProcessDefinitionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format or that latest is used with other parameters other than key and keyLike. The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a process definition</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessDefinitionResponse> GetProcessDefinitionAsync(string processDefinitionId)
        {
            return GetProcessDefinitionAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessDefinitionResponse> GetProcessDefinitionAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessDefinitionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Execute actions for a process definition</summary>
        /// <returns>Indicates action has been executed for the specified process. (category altered, activate or suspend)</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessDefinitionResponse> ExecuteProcessDefinitionActionAsync(string processDefinitionId, ProcessDefinitionActionRequest body)
        {
            return ExecuteProcessDefinitionActionAsync(processDefinitionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute actions for a process definition</summary>
        /// <returns>Indicates action has been executed for the specified process. (category altered, activate or suspend)</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessDefinitionResponse> ExecuteProcessDefinitionActionAsync(string processDefinitionId, ProcessDefinitionActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessDefinitionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates no category was defined in the request body.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition is already suspended or active.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Batch migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and batch migration was started.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task BatchMigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body)
        {
            return BatchMigrateInstancesOfProcessDefinitionAsync(processDefinitionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Batch migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and batch migration was started.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task BatchMigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/batch-migrate");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List decision tables for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the decision tables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DecisionTableResponse>> ListProcessDefinitionDecisionTablesAsync(string processDefinitionId)
        {
            return ListProcessDefinitionDecisionTablesAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List decision tables for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the decision tables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DecisionTableResponse>> ListProcessDefinitionDecisionTablesAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/decision-tables");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<DecisionTableResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List form definitions for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the form definitions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FormDefinitionResponse>> ListProcessDefinitionFormDefinitionsAsync(string processDefinitionId)
        {
            return ListProcessDefinitionFormDefinitionsAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List form definitions for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the form definitions are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FormDefinitionResponse>> ListProcessDefinitionFormDefinitionsAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/form-definitions");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<FormDefinitionResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List candidate starters for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessDefinitionIdentityLinksAsync(string processDefinitionId)
        {
            return ListProcessDefinitionIdentityLinksAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List candidate starters for a process-definition</summary>
        /// <returns>Indicates the process definition was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessDefinitionIdentityLinksAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/identitylinks");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestIdentityLink>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Add a candidate starter to a process definition</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestIdentityLink> CreateIdentityLinkAsync(string processDefinitionId, RestIdentityLink body)
        {
            return CreateIdentityLinkAsync(processDefinitionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add a candidate starter to a process definition</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestIdentityLink> CreateIdentityLinkAsync(string processDefinitionId, RestIdentityLink body, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/identitylinks");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestIdentityLink>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the process definition was found and the identity link was created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the body does not contain the correct information.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestIdentityLink> GetIdentityLinkAsync(string processDefinitionId, string family, string identityId)
        {
            return GetIdentityLinkAsync(processDefinitionId, family, identityId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestIdentityLink> GetIdentityLinkAsync(string processDefinitionId, string family, string identityId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            if (family == null)
                throw new System.ArgumentNullException("family");

            if (identityId == null)
                throw new System.ArgumentNullException("identityId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/identitylinks/{family}/{identityId}");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{family}", System.Uri.EscapeDataString(ConvertToString(family, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{identityId}", System.Uri.EscapeDataString(ConvertToString(identityId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestIdentityLink>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found or the process definition does not have an identity-link that matches the url.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was removed. The response body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteIdentityLinkAsync(string processDefinitionId, string family, string identityId)
        {
            return DeleteIdentityLinkAsync(processDefinitionId, family, identityId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a candidate starter from a process definition</summary>
        /// <returns>Indicates the process definition was found and the identity link was removed. The response body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteIdentityLinkAsync(string processDefinitionId, string family, string identityId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            if (family == null)
                throw new System.ArgumentNullException("family");

            if (identityId == null)
                throw new System.ArgumentNullException("identityId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/identitylinks/{family}/{identityId}");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{family}", System.Uri.EscapeDataString(ConvertToString(family, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{identityId}", System.Uri.EscapeDataString(ConvertToString(identityId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found or the process definition does not have an identity-link that matches the url.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a process definition image</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelResourceAsync(string processDefinitionId)
        {
            return GetModelResourceAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition image</summary>
        /// <returns>Indicates request was successful and the process-definitions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetModelResourceAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/image");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("image/png"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task MigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body)
        {
            return MigrateInstancesOfProcessDefinitionAsync(processDefinitionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Migrate all instances of process definition</summary>
        /// <returns>Indicates process instances were found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task MigrateInstancesOfProcessDefinitionAsync(string processDefinitionId, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/migrate");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a process definition BPMN model</summary>
        /// <returns>Indicates the process definition was found and the model is returned. The response contains the full process definition model.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<BpmnModel> GetBpmnModelResourceAsync(string processDefinitionId)
        {
            return GetBpmnModelResourceAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition BPMN model</summary>
        /// <returns>Indicates the process definition was found and the model is returned. The response contains the full process definition model.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<BpmnModel> GetBpmnModelResourceAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/model");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BpmnModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a process definition resource content</summary>
        /// <returns>Indicates both process definition and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessDefinitionResourceAsync(string processDefinitionId)
        {
            return GetProcessDefinitionResourceAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition resource content</summary>
        /// <returns>Indicates both process definition and resource have been found and the resource data has been returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessDefinitionResourceAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/resourcedata");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found or there is no resource with the given id present in the process definition. The status-description contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a process definition start form</summary>
        /// <returns>Indicates request was successful and the process definition form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetProcessDefinitionStartFormAsync(string processDefinitionId)
        {
            return GetProcessDefinitionStartFormAsync(processDefinitionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process definition start form</summary>
        /// <returns>Indicates request was successful and the process definition form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetProcessDefinitionStartFormAsync(string processDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (processDefinitionId == null)
                throw new System.ArgumentNullException("processDefinitionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("repository/process-definitions/{processDefinitionId}/start-form");
            urlBuilder_.Replace("{processDefinitionId}", System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process definition was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of event subscriptions</summary>
        /// <param name="id">Only return event subscriptions with the given id</param>
        /// <param name="eventType">Only return event subscriptions with the given event type</param>
        /// <param name="eventName">Only return event subscriptions with the given event name</param>
        /// <param name="activityId">Only return event subscriptions with the given activity id</param>
        /// <param name="executionId">Only return event subscriptions with the given execution id</param>
        /// <param name="processInstanceId">Only return event subscriptions part of a process with the given id</param>
        /// <param name="processDefinitionId">Only return event subscriptions with the given process definition id</param>
        /// <param name="scopeId">Only return event subscriptions part of a scope with the given id</param>
        /// <param name="scopeDefinitionId">Only return event subscriptions with the given scope definition id</param>
        /// <param name="createdBefore">Only return event subscriptions which are created before the given date.</param>
        /// <param name="createdAfter">Only return event subscriptions which are created after the given date.</param>
        /// <param name="tenantId">Only return event subscriptions with the given tenant id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested event subscriptions were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseEventSubscriptionResponse> ListEventSubscriptionsAsync(string id, string eventType, string eventName, string activityId, string executionId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, string tenantId, Sort10? sort)
        {
            return ListEventSubscriptionsAsync(id, eventType, eventName, activityId, executionId, processInstanceId, processDefinitionId, scopeId, scopeDefinitionId, createdBefore, createdAfter, tenantId, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of event subscriptions</summary>
        /// <param name="id">Only return event subscriptions with the given id</param>
        /// <param name="eventType">Only return event subscriptions with the given event type</param>
        /// <param name="eventName">Only return event subscriptions with the given event name</param>
        /// <param name="activityId">Only return event subscriptions with the given activity id</param>
        /// <param name="executionId">Only return event subscriptions with the given execution id</param>
        /// <param name="processInstanceId">Only return event subscriptions part of a process with the given id</param>
        /// <param name="processDefinitionId">Only return event subscriptions with the given process definition id</param>
        /// <param name="scopeId">Only return event subscriptions part of a scope with the given id</param>
        /// <param name="scopeDefinitionId">Only return event subscriptions with the given scope definition id</param>
        /// <param name="createdBefore">Only return event subscriptions which are created before the given date.</param>
        /// <param name="createdAfter">Only return event subscriptions which are created after the given date.</param>
        /// <param name="tenantId">Only return event subscriptions with the given tenant id.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates the requested event subscriptions were returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseEventSubscriptionResponse> ListEventSubscriptionsAsync(string id, string eventType, string eventName, string activityId, string executionId, string processInstanceId, string processDefinitionId, string scopeId, string scopeDefinitionId, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, string tenantId, Sort10? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/event-subscriptions?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("eventType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(eventType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("eventName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(eventName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (activityId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createdBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createdBefore") + "=").Append(System.Uri.EscapeDataString(createdBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createdAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createdAfter") + "=").Append(System.Uri.EscapeDataString(createdAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseEventSubscriptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal value has been used in a url query parameter. Status description contains additional details about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single event subscription</summary>
        /// <returns>Indicates the event subscription exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<EventSubscriptionResponse> GetEventSubscriptionAsync(string eventSubscriptionId)
        {
            return GetEventSubscriptionAsync(eventSubscriptionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single event subscription</summary>
        /// <returns>Indicates the event subscription exists and is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<EventSubscriptionResponse> GetEventSubscriptionAsync(string eventSubscriptionId, System.Threading.CancellationToken cancellationToken)
        {
            if (eventSubscriptionId == null)
                throw new System.ArgumentNullException("eventSubscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/event-subscriptions/{eventSubscriptionId}");
            urlBuilder_.Replace("{eventSubscriptionId}", System.Uri.EscapeDataString(ConvertToString(eventSubscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventSubscriptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested event subscription does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of executions</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="activityId">Only return executions with the given activity id.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processInstanceId">Only return executions which are part of the process instance with the given id.</param>
        /// <param name="messageEventSubscriptionName">Only return executions which are subscribed to a message with the given name.</param>
        /// <param name="signalEventSubscriptionName">Only return executions which are subscribed to a signal with the given name.</param>
        /// <param name="parentId">Only return executions which are a direct child of the given execution.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseExecutionResponse> ListExecutionsAsync(string id, string activityId, string processDefinitionKey, string processDefinitionId, string processInstanceId, string messageEventSubscriptionName, string signalEventSubscriptionName, string parentId, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort11? sort)
        {
            return ListExecutionsAsync(id, activityId, processDefinitionKey, processDefinitionId, processInstanceId, messageEventSubscriptionName, signalEventSubscriptionName, parentId, tenantId, tenantIdLike, withoutTenantId, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of executions</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="activityId">Only return executions with the given activity id.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processInstanceId">Only return executions which are part of the process instance with the given id.</param>
        /// <param name="messageEventSubscriptionName">Only return executions which are subscribed to a message with the given name.</param>
        /// <param name="signalEventSubscriptionName">Only return executions which are subscribed to a signal with the given name.</param>
        /// <param name="parentId">Only return executions which are a direct child of the given execution.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseExecutionResponse> ListExecutionsAsync(string id, string activityId, string processDefinitionKey, string processDefinitionId, string processInstanceId, string messageEventSubscriptionName, string signalEventSubscriptionName, string parentId, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort11? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (activityId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activityId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activityId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (messageEventSubscriptionName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("messageEventSubscriptionName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(messageEventSubscriptionName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (signalEventSubscriptionName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("signalEventSubscriptionName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(signalEventSubscriptionName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (parentId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("parentId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(parentId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseExecutionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format . The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Signal event received</summary>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ExecuteExecutionActionAsync(ExecutionActionRequest body)
        {
            return ExecuteExecutionActionAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Signal event received</summary>
        /// <returns>Indicates request was successful and the executions are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ExecuteExecutionActionAsync(ExecutionActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format . The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get an execution</summary>
        /// <returns>Indicates the execution was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ExecutionResponse> GetExecutionAsync(string executionId)
        {
            return GetExecutionAsync(executionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get an execution</summary>
        /// <returns>Indicates the execution was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ExecutionResponse> GetExecutionAsync(string executionId, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExecutionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Execute an action on an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ExecutionResponse> PerformExecutionActionAsync(string executionId, ExecutionActionRequest body)
        {
            return PerformExecutionActionAsync(executionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute an action on an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ExecutionResponse> PerformExecutionActionAsync(string executionId, ExecutionActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExecutionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was found, the action was performed and the action caused the execution to end.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates an illegal action was requested, required parameters are missing in the request body or illegal variables are passed in. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List active activities in an execution</summary>
        /// <returns>Indicates the execution was found and activities are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ListExecutionActiveActivitiesAsync(string executionId)
        {
            return ListExecutionActiveActivitiesAsync(executionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List active activities in an execution</summary>
        /// <returns>Indicates the execution was found and activities are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ListExecutionActiveActivitiesAsync(string executionId, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/activities");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Change the state of an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ChangeExecutionActivityStateAsync(string executionId, ExecutionChangeActivityStateRequest body)
        {
            return ChangeExecutionActivityStateAsync(executionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Change the state of an execution</summary>
        /// <returns>Indicates the execution was found and the action is performed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ChangeExecutionActivityStateAsync(string executionId, ExecutionChangeActivityStateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/change-state");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListExecutionVariablesAsync(string executionId, string scope)
        {
            return ListExecutionVariablesAsync(executionId, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListExecutionVariablesAsync(string executionId, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables?");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestVariable>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CreateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope)
        {
            return CreateExecutionVariableAsync(executionId, body, name, type, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CreateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was found and variable is created/updated.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the request body is incomplete or contains illegal values. The status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was found but already contains a variable with the given name. Use the update-method instead.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CreateOrUpdateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope)
        {
            return CreateOrUpdateExecutionVariableAsync(executionId, body, name, type, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update variables on an execution</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CreateOrUpdateExecutionVariableAsync(string executionId, ExecutionVariableCollectionResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the execution was found and variable is created/updated.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the request body is incomplete or contains illegal values. The status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete all variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables have been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteLocalVariablesAsync(string executionId)
        {
            return DeleteLocalVariablesAsync(executionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all variables for an execution</summary>
        /// <returns>Indicates the execution was found and variables have been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteLocalVariablesAsync(string executionId, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestVariable> GetExecutionVariableAsync(string executionId, string variableName, string scope)
        {
            return GetExecutionVariableAsync(executionId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestVariable> GetExecutionVariableAsync(string executionId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables/{variableName}?");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestVariable>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the request body is incomplete or contains illegal values. The status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found or the execution does not have a variable with the given name in the requested scope (in case scope-query parameter was omitted, variable does not exist in local and global scope). Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a variable on an execution</summary>
        /// <param name="body">Update a variable on an execution</param>
        /// <returns>Indicates both the process instance and variable were found and variable is updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestVariable> UpdateExecutionVariableAsync(string executionId, string variableName, ExecutionVariableResource body, FileParameter file, string name, string type, string scope)
        {
            return UpdateExecutionVariableAsync(executionId, variableName, body, file, name, type, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a variable on an execution</summary>
        /// <param name="body">Update a variable on an execution</param>
        /// <returns>Indicates both the process instance and variable were found and variable is updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestVariable> UpdateExecutionVariableAsync(string executionId, string variableName, ExecutionVariableResource body, FileParameter file, string name, string type, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables/{variableName}");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestVariable>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found or the process instance does not have a variable with the given name. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable has been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeletedExecutionVariableAsync(string executionId, string variableName, string scope)
        {
            return DeletedExecutionVariableAsync(executionId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a variable for an execution</summary>
        /// <returns>Indicates both the execution and variable were found and variable has been deleted.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeletedExecutionVariableAsync(string executionId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables/{variableName}?");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found or the execution does not have a variable with the given name in the requested scope. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for an execution</summary>
        /// <returns>Indicates the execution was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExecutionVariableDataAsync(string executionId, string variableName, string scope)
        {
            return GetExecutionVariableDataAsync(executionId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for an execution</summary>
        /// <returns>Indicates the execution was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetExecutionVariableDataAsync(string executionId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (executionId == null)
                throw new System.ArgumentNullException("executionId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/executions/{executionId}/variables/{variableName}/data?");
            urlBuilder_.Replace("{executionId}", System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested execution was not found or the task does not have a variable with the given name (in the given scope). Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List process instances</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models like the given name.</param>
        /// <param name="nameLikeIgnoreCase">Only return models like the given name ignoring case.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processDefinitionCategory">Only return process instances with the given process definition category.</param>
        /// <param name="processDefinitionVersion">Only return process instances with the given process definition version.</param>
        /// <param name="processDefinitionEngineVersion">Only return process instances with the given process definition engine version.</param>
        /// <param name="businessKey">Only return process instances with the given businessKey.</param>
        /// <param name="businessKeyLike">Only return process instances with the businessKey like the given key.</param>
        /// <param name="startedBy">Only return process instances started by the given user.</param>
        /// <param name="startedBefore">Only return process instances started before the given date.</param>
        /// <param name="startedAfter">Only return process instances started after the given date.</param>
        /// <param name="involvedUser">Only return process instances in which the given user is involved.</param>
        /// <param name="suspended">If true, only return process instance which are suspended. If false, only return process instances which are not suspended (active).</param>
        /// <param name="superProcessInstanceId">Only return process instances which have the given super process-instance id (for processes that have a call-activities).</param>
        /// <param name="subProcessInstanceId">Only return process instances which have the given sub process-instance id (for processes started as a call-activity).</param>
        /// <param name="excludeSubprocesses">Return only process instances which are not sub processes.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="callbackId">Only return process instances with the given callbackId.</param>
        /// <param name="callbackType">Only return process instances with the given callbackType.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> ListProcessInstancesAsync(string id, string name, string nameLike, string nameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionCategory, int? processDefinitionVersion, string processDefinitionEngineVersion, string businessKey, string businessKeyLike, string startedBy, System.DateTimeOffset? startedBefore, System.DateTimeOffset? startedAfter, string involvedUser, bool? suspended, string superProcessInstanceId, string subProcessInstanceId, bool? excludeSubprocesses, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort12? sort)
        {
            return ListProcessInstancesAsync(id, name, nameLike, nameLikeIgnoreCase, processDefinitionKey, processDefinitionId, processDefinitionCategory, processDefinitionVersion, processDefinitionEngineVersion, businessKey, businessKeyLike, startedBy, startedBefore, startedAfter, involvedUser, suspended, superProcessInstanceId, subProcessInstanceId, excludeSubprocesses, includeProcessVariables, callbackId, callbackType, tenantId, tenantIdLike, withoutTenantId, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List process instances</summary>
        /// <param name="id">Only return models with the given version.</param>
        /// <param name="name">Only return models with the given name.</param>
        /// <param name="nameLike">Only return models like the given name.</param>
        /// <param name="nameLikeIgnoreCase">Only return models like the given name ignoring case.</param>
        /// <param name="processDefinitionKey">Only return process instances with the given process definition key.</param>
        /// <param name="processDefinitionId">Only return process instances with the given process definition id.</param>
        /// <param name="processDefinitionCategory">Only return process instances with the given process definition category.</param>
        /// <param name="processDefinitionVersion">Only return process instances with the given process definition version.</param>
        /// <param name="processDefinitionEngineVersion">Only return process instances with the given process definition engine version.</param>
        /// <param name="businessKey">Only return process instances with the given businessKey.</param>
        /// <param name="businessKeyLike">Only return process instances with the businessKey like the given key.</param>
        /// <param name="startedBy">Only return process instances started by the given user.</param>
        /// <param name="startedBefore">Only return process instances started before the given date.</param>
        /// <param name="startedAfter">Only return process instances started after the given date.</param>
        /// <param name="involvedUser">Only return process instances in which the given user is involved.</param>
        /// <param name="suspended">If true, only return process instance which are suspended. If false, only return process instances which are not suspended (active).</param>
        /// <param name="superProcessInstanceId">Only return process instances which have the given super process-instance id (for processes that have a call-activities).</param>
        /// <param name="subProcessInstanceId">Only return process instances which have the given sub process-instance id (for processes started as a call-activity).</param>
        /// <param name="excludeSubprocesses">Return only process instances which are not sub processes.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="callbackId">Only return process instances with the given callbackId.</param>
        /// <param name="callbackType">Only return process instances with the given callbackType.</param>
        /// <param name="tenantId">Only return process instances with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return process instances with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="sort">Property to sort on, to be used together with the order.</param>
        /// <returns>Indicates request was successful and the process-instances are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseProcessInstanceResponse> ListProcessInstancesAsync(string id, string name, string nameLike, string nameLikeIgnoreCase, string processDefinitionKey, string processDefinitionId, string processDefinitionCategory, int? processDefinitionVersion, string processDefinitionEngineVersion, string businessKey, string businessKeyLike, string startedBy, System.DateTimeOffset? startedBefore, System.DateTimeOffset? startedAfter, string involvedUser, bool? suspended, string superProcessInstanceId, string subProcessInstanceId, bool? excludeSubprocesses, bool? includeProcessVariables, string callbackId, string callbackType, string tenantId, string tenantIdLike, bool? withoutTenantId, Sort12? sort, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances?");
            if (id != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLikeIgnoreCase != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLikeIgnoreCase") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLikeIgnoreCase, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionCategory != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionCategory") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionCategory, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionEngineVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionEngineVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionEngineVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (businessKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("businessKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(businessKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (businessKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("businessKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(businessKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startedBy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startedBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startedBy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startedBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startedBefore") + "=").Append(System.Uri.EscapeDataString(startedBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startedAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startedAfter") + "=").Append(System.Uri.EscapeDataString(startedAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (involvedUser != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("involvedUser") + "=").Append(System.Uri.EscapeDataString(ConvertToString(involvedUser, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (suspended != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("suspended") + "=").Append(System.Uri.EscapeDataString(ConvertToString(suspended, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (superProcessInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("superProcessInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(superProcessInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (subProcessInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("subProcessInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(subProcessInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (excludeSubprocesses != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("excludeSubprocesses") + "=").Append(System.Uri.EscapeDataString(ConvertToString(excludeSubprocesses, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeProcessVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeProcessVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeProcessVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (callbackId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("callbackId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(callbackId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (callbackType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("callbackType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(callbackType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format . The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Start a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessInstanceResponse> CreateProcessInstanceAsync(ProcessInstanceCreateRequest body)
        {
            return CreateProcessInstanceAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Start a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessInstanceResponse> CreateProcessInstanceAsync(ProcessInstanceCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates either the process-definition was not found (based on id or key), no process is started by sending the given message or an invalid variable has been passed. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a process instance</summary>
        /// <returns>Indicates the process instance was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessInstanceResponse> GetProcessInstanceAsync(string processInstanceId)
        {
            return GetProcessInstanceAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a process instance</summary>
        /// <returns>Indicates the process instance was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessInstanceResponse> GetProcessInstanceAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Activate or suspend a process instance</summary>
        /// <returns>Indicates the process instance was found and action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProcessInstanceResponse> PerformProcessInstanceActionAsync(string processInstanceId, ProcessInstanceActionRequest body)
        {
            return PerformProcessInstanceActionAsync(processInstanceId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Activate or suspend a process instance</summary>
        /// <returns>Indicates the process instance was found and action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProcessInstanceResponse> PerformProcessInstanceActionAsync(string processInstanceId, ProcessInstanceActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProcessInstanceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("\t\nIndicates an invalid action was supplied.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance action cannot be executed since the process-instance is already activated/suspended.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a process instance</summary>
        /// <returns>Indicates the process instance was found and deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteProcessInstanceAsync(string processInstanceId, string deleteReason)
        {
            return DeleteProcessInstanceAsync(processInstanceId, deleteReason, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a process instance</summary>
        /// <returns>Indicates the process instance was found and deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteProcessInstanceAsync(string processInstanceId, string deleteReason, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}?");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteReason != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteReason") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteReason, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Change the state a process instance</summary>
        /// <returns>Indicates the process instance was found and change state activity was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ChangeActivityStateAsync(string processInstanceId, ExecutionChangeActivityStateRequest body)
        {
            return ChangeActivityStateAsync(processInstanceId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Change the state a process instance</summary>
        /// <returns>Indicates the process instance was found and change state activity was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ChangeActivityStateAsync(string processInstanceId, ExecutionChangeActivityStateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/change-state");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance action cannot be executed since the process-instance is already activated/suspended.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get diagram for a process instance</summary>
        /// <returns>Indicates the process instance was found and the diagram was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceDiagramAsync(string processInstanceId)
        {
            return GetProcessInstanceDiagramAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get diagram for a process instance</summary>
        /// <returns>Indicates the process instance was found and the diagram was returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceDiagramAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/diagram");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found but the process does not contain any graphical information (BPMN:DI) and no diagram can be created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Evaluate the conditions of a process instance</summary>
        /// <returns>Indicates the process instance was found and the evaluation of the conditions was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task EvaluateConditionsAsync(string processInstanceId)
        {
            return EvaluateConditionsAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Evaluate the conditions of a process instance</summary>
        /// <returns>Indicates the process instance was found and the evaluation of the conditions was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task EvaluateConditionsAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/evaluate-conditions");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance action cannot be executed since the process-instance is already activated/suspended.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get involved people for process instance</summary>
        /// <returns>Indicates the process instance was found and links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessInstanceIdentityLinksAsync(string processInstanceId)
        {
            return ListProcessInstanceIdentityLinksAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get involved people for process instance</summary>
        /// <returns>Indicates the process instance was found and links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListProcessInstanceIdentityLinksAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/identitylinks");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestIdentityLink>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Add an involved user to a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestIdentityLink> CreateProcessInstanceIdentityLinksAsync(string processInstanceId, RestIdentityLink body)
        {
            return CreateProcessInstanceIdentityLinksAsync(processInstanceId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Add an involved user to a process instance</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestIdentityLink> CreateProcessInstanceIdentityLinksAsync(string processInstanceId, RestIdentityLink body, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/identitylinks");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestIdentityLink>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the process instance was found and the link is created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested body did not contain a userId or a type.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a specific involved people from process instance</summary>
        /// <returns>Indicates the process instance was found and the specified link is retrieved.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestIdentityLink> GetProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type)
        {
            return GetProcessInstanceIdentityLinksAsync(processInstanceId, identityId, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a specific involved people from process instance</summary>
        /// <returns>Indicates the process instance was found and the specified link is retrieved.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestIdentityLink> GetProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (identityId == null)
                throw new System.ArgumentNullException("identityId");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/identitylinks/users/{identityId}/{type}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{identityId}", System.Uri.EscapeDataString(ConvertToString(identityId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{type}", System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestIdentityLink>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found or the link to delete does not exist. The response status contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Remove an involved user to from process instance</summary>
        /// <returns>Indicates the process instance was found and the link has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type)
        {
            return DeleteProcessInstanceIdentityLinksAsync(processInstanceId, identityId, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Remove an involved user to from process instance</summary>
        /// <returns>Indicates the process instance was found and the link has been deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteProcessInstanceIdentityLinksAsync(string processInstanceId, string identityId, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (identityId == null)
                throw new System.ArgumentNullException("identityId");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/identitylinks/users/{identityId}/{type}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{identityId}", System.Uri.EscapeDataString(ConvertToString(identityId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{type}", System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found or the link to delete does not exist. The response status contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Inject activity in a process instance</summary>
        /// <returns>Indicates the process instance was updated and the activity injection was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task InjectActivityInProcessInstanceAsync(string processInstanceId, InjectActivityRequest body)
        {
            return InjectActivityInProcessInstanceAsync(processInstanceId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Inject activity in a process instance</summary>
        /// <returns>Indicates the process instance was updated and the activity injection was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task InjectActivityInProcessInstanceAsync(string processInstanceId, InjectActivityRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/inject");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance action cannot be executed since the process-instance is already activated/suspended.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Migrate process instance</summary>
        /// <returns>Indicates the process instance was found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task MigrateProcessInstanceAsync(string processInstanceId, string body)
        {
            return MigrateProcessInstanceAsync(processInstanceId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Migrate process instance</summary>
        /// <returns>Indicates the process instance was found and migration was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task MigrateProcessInstanceAsync(string processInstanceId, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/migrate");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance action cannot be executed since the process-instance is already activated/suspended.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List variables for a process instance</summary>
        /// <returns>Indicates the process instance was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListProcessInstanceVariablesAsync(string processInstanceId, string scope)
        {
            return ListProcessInstanceVariablesAsync(processInstanceId, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List variables for a process instance</summary>
        /// <returns>Indicates the process instance was found and variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListProcessInstanceVariablesAsync(string processInstanceId, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables?");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestVariable>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create variables or new binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CreateProcessInstanceVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type)
        {
            return CreateProcessInstanceVariableAsync(processInstanceId, body, file, name, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create variables or new binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CreateProcessInstanceVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the process instance was found and variable is created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the request body is incomplete or contains illegal values. The status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the process instance was found but already contains a variable with the given name (only thrown when POST method is used). Use the update-method instead.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a multiple/single (non)binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CreateOrUpdateProcessVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type)
        {
            return CreateOrUpdateProcessVariableAsync(processInstanceId, body, file, name, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a multiple/single (non)binary variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CreateOrUpdateProcessVariableAsync(string processInstanceId, ProcessInstanceVariableCollectionResource body, FileParameter file, string name, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the process instance was found and variable is created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the request body is incomplete or contains illegal values. The status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 415)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the serializable data contains an object for which no class is present in the JVM running the Flowable engine and therefore cannot be deserialized.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete all variables</summary>
        /// <returns>Indicates variables were found and have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteLocalProcessVariableAsync(string processInstanceId)
        {
            return DeleteLocalProcessVariableAsync(processInstanceId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all variables</summary>
        /// <returns>Indicates variables were found and have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteLocalProcessVariableAsync(string processInstanceId, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a variable for a process instance</summary>
        /// <returns>Indicates both the process instance and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestVariable> GetProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope)
        {
            return GetProcessInstanceVariableAsync(processInstanceId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a variable for a process instance</summary>
        /// <returns>Indicates both the process instance and variable were found and variable is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestVariable> GetProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables/{variableName}?");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestVariable>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found or the process instance does not have a variable with the given name. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a single variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestVariable> UpdateProcessInstanceVariableAsync(string processInstanceId, string variableName, ProcessInstanceVariableResource body, FileParameter file, string name, string type)
        {
            return UpdateProcessInstanceVariableAsync(processInstanceId, variableName, body, file, name, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a single variable on a process instance</summary>
        /// <param name="body">Create a variable on a process instance</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestVariable> UpdateProcessInstanceVariableAsync(string processInstanceId, string variableName, ProcessInstanceVariableResource body, FileParameter file, string name, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables/{variableName}");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestVariable>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates both the process instance and variable were found and variable is updated.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested process instance was not found or the process instance does not have a variable with the given name. Status description contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a variable</summary>
        /// <returns>Indicates the variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope)
        {
            return DeleteProcessInstanceVariableAsync(processInstanceId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a variable</summary>
        /// <returns>Indicates the variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync(string processInstanceId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables/{variableName}?");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested variable was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for a variable</summary>
        /// <returns>Indicates the process instance was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceVariableDataAsync(string processInstanceId, string variableName, string scope)
        {
            return GetProcessInstanceVariableDataAsync(processInstanceId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a variable</summary>
        /// <returns>Indicates the process instance was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetProcessInstanceVariableDataAsync(string processInstanceId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (processInstanceId == null)
                throw new System.ArgumentNullException("processInstanceId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/process-instances/{processInstanceId}/variables/{variableName}/data?");
            urlBuilder_.Replace("{processInstanceId}", System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have a variable with the given name (in the given scope). Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Signal event received</summary>
        /// <returns>Indicated signal processing is queued as a job, ready to be executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task SignalEventReceivedAsync(SignalEventReceivedRequest body)
        {
            return SignalEventReceivedAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Signal event received</summary>
        /// <returns>Indicated signal processing is queued as a job, ready to be executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task SignalEventReceivedAsync(SignalEventReceivedRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/signals");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Signal not processed. The signal name is missing or variables are used together with async, which is not allowed. Response body contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of tasks</summary>
        /// <param name="name">Only return models with the given version.</param>
        /// <param name="nameLike">Only return tasks with a name like the given name.</param>
        /// <param name="description">Only return tasks with the given description.</param>
        /// <param name="priority">Only return tasks with the given priority.</param>
        /// <param name="minimumPriority">Only return tasks with a priority greater than the given value.</param>
        /// <param name="maximumPriority">Only return tasks with a priority lower than the given value.</param>
        /// <param name="assignee">Only return tasks assigned to the given user.</param>
        /// <param name="assigneeLike">Only return tasks assigned with an assignee like the given value.</param>
        /// <param name="owner">Only return tasks owned by the given user.</param>
        /// <param name="ownerLike">Only return tasks assigned with an owner like the given value.</param>
        /// <param name="unassigned">Only return tasks that are not assigned to anyone. If false is passed, the value is ignored.</param>
        /// <param name="delegationState">Only return tasks that have the given delegation state. Possible values are pending and resolved.</param>
        /// <param name="candidateUser">Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of.</param>
        /// <param name="candidateGroup">Only return tasks that can be claimed by a user in the given group.</param>
        /// <param name="candidateGroups">Only return tasks that can be claimed by a user in the given groups. Values split by comma.</param>
        /// <param name="involvedUser">Only return tasks in which the given user is involved.</param>
        /// <param name="taskDefinitionKey">Only return tasks with the given task definition id.</param>
        /// <param name="taskDefinitionKeyLike">Only return tasks with a given task definition id like the given value.</param>
        /// <param name="taskDefinitionKeys">Only return tasks with the given task definition ids.</param>
        /// <param name="processInstanceId">Only return tasks which are part of the process instance with the given id.</param>
        /// <param name="processInstanceIdWithChildren">Only return tasks which are part of the process instance and its children with the given id.</param>
        /// <param name="processInstanceBusinessKey">Only return tasks which are part of the process instance with the given business key.</param>
        /// <param name="processInstanceBusinessKeyLike">Only return tasks which are part of the process instance which has a business key like the given value.</param>
        /// <param name="processDefinitionId">Only return tasks which are part of a process instance which has a process definition with the given id.</param>
        /// <param name="processDefinitionKey">Only return tasks which are part of a process instance which has a process definition with the given key.</param>
        /// <param name="processDefinitionKeyLike">Only return tasks which are part of a process instance which has a process definition with a key like the given value.</param>
        /// <param name="processDefinitionName">Only return tasks which are part of a process instance which has a process definition with the given name.</param>
        /// <param name="processDefinitionNameLike">Only return tasks which are part of a process instance which has a process definition with a name like the given value.</param>
        /// <param name="executionId">Only return tasks which are part of the execution with the given id.</param>
        /// <param name="createdOn">Only return tasks which are created on the given date.</param>
        /// <param name="createdBefore">Only return tasks which are created before the given date.</param>
        /// <param name="createdAfter">Only return tasks which are created after the given date.</param>
        /// <param name="dueOn">Only return tasks which are due on the given date.</param>
        /// <param name="dueBefore">Only return tasks which are due before the given date.</param>
        /// <param name="dueAfter">Only return tasks which are due after the given date.</param>
        /// <param name="withoutDueDate">Only return tasks which do not have a due date. The property is ignored if the value is false.</param>
        /// <param name="excludeSubTasks">Only return tasks that are not a subtask of another task.</param>
        /// <param name="active">If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned.</param>
        /// <param name="includeTaskLocalVariables">Indication to include task local variables in the result.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="scopeDefinitionId">Only return tasks with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return tasks with the given scopeId.</param>
        /// <param name="scopeType">Only return tasks with the given scopeType.</param>
        /// <param name="tenantId">Only return tasks with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return tasks with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="candidateOrAssigned">Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups).</param>
        /// <param name="category">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DataResponseTaskResponse> ListTasksAsync(string name, string nameLike, string description, string priority, string minimumPriority, string maximumPriority, string assignee, string assigneeLike, string owner, string ownerLike, string unassigned, string delegationState, string candidateUser, string candidateGroup, string candidateGroups, string involvedUser, string taskDefinitionKey, string taskDefinitionKeyLike, string taskDefinitionKeys, string processInstanceId, string processInstanceIdWithChildren, string processInstanceBusinessKey, string processInstanceBusinessKeyLike, string processDefinitionId, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionName, string processDefinitionNameLike, string executionId, System.DateTimeOffset? createdOn, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, System.DateTimeOffset? dueOn, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, bool? withoutDueDate, bool? excludeSubTasks, bool? active, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId, string candidateOrAssigned, string category)
        {
            return ListTasksAsync(name, nameLike, description, priority, minimumPriority, maximumPriority, assignee, assigneeLike, owner, ownerLike, unassigned, delegationState, candidateUser, candidateGroup, candidateGroups, involvedUser, taskDefinitionKey, taskDefinitionKeyLike, taskDefinitionKeys, processInstanceId, processInstanceIdWithChildren, processInstanceBusinessKey, processInstanceBusinessKeyLike, processDefinitionId, processDefinitionKey, processDefinitionKeyLike, processDefinitionName, processDefinitionNameLike, executionId, createdOn, createdBefore, createdAfter, dueOn, dueBefore, dueAfter, withoutDueDate, excludeSubTasks, active, includeTaskLocalVariables, includeProcessVariables, scopeDefinitionId, scopeId, scopeType, tenantId, tenantIdLike, withoutTenantId, candidateOrAssigned, category, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of tasks</summary>
        /// <param name="name">Only return models with the given version.</param>
        /// <param name="nameLike">Only return tasks with a name like the given name.</param>
        /// <param name="description">Only return tasks with the given description.</param>
        /// <param name="priority">Only return tasks with the given priority.</param>
        /// <param name="minimumPriority">Only return tasks with a priority greater than the given value.</param>
        /// <param name="maximumPriority">Only return tasks with a priority lower than the given value.</param>
        /// <param name="assignee">Only return tasks assigned to the given user.</param>
        /// <param name="assigneeLike">Only return tasks assigned with an assignee like the given value.</param>
        /// <param name="owner">Only return tasks owned by the given user.</param>
        /// <param name="ownerLike">Only return tasks assigned with an owner like the given value.</param>
        /// <param name="unassigned">Only return tasks that are not assigned to anyone. If false is passed, the value is ignored.</param>
        /// <param name="delegationState">Only return tasks that have the given delegation state. Possible values are pending and resolved.</param>
        /// <param name="candidateUser">Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of.</param>
        /// <param name="candidateGroup">Only return tasks that can be claimed by a user in the given group.</param>
        /// <param name="candidateGroups">Only return tasks that can be claimed by a user in the given groups. Values split by comma.</param>
        /// <param name="involvedUser">Only return tasks in which the given user is involved.</param>
        /// <param name="taskDefinitionKey">Only return tasks with the given task definition id.</param>
        /// <param name="taskDefinitionKeyLike">Only return tasks with a given task definition id like the given value.</param>
        /// <param name="taskDefinitionKeys">Only return tasks with the given task definition ids.</param>
        /// <param name="processInstanceId">Only return tasks which are part of the process instance with the given id.</param>
        /// <param name="processInstanceIdWithChildren">Only return tasks which are part of the process instance and its children with the given id.</param>
        /// <param name="processInstanceBusinessKey">Only return tasks which are part of the process instance with the given business key.</param>
        /// <param name="processInstanceBusinessKeyLike">Only return tasks which are part of the process instance which has a business key like the given value.</param>
        /// <param name="processDefinitionId">Only return tasks which are part of a process instance which has a process definition with the given id.</param>
        /// <param name="processDefinitionKey">Only return tasks which are part of a process instance which has a process definition with the given key.</param>
        /// <param name="processDefinitionKeyLike">Only return tasks which are part of a process instance which has a process definition with a key like the given value.</param>
        /// <param name="processDefinitionName">Only return tasks which are part of a process instance which has a process definition with the given name.</param>
        /// <param name="processDefinitionNameLike">Only return tasks which are part of a process instance which has a process definition with a name like the given value.</param>
        /// <param name="executionId">Only return tasks which are part of the execution with the given id.</param>
        /// <param name="createdOn">Only return tasks which are created on the given date.</param>
        /// <param name="createdBefore">Only return tasks which are created before the given date.</param>
        /// <param name="createdAfter">Only return tasks which are created after the given date.</param>
        /// <param name="dueOn">Only return tasks which are due on the given date.</param>
        /// <param name="dueBefore">Only return tasks which are due before the given date.</param>
        /// <param name="dueAfter">Only return tasks which are due after the given date.</param>
        /// <param name="withoutDueDate">Only return tasks which do not have a due date. The property is ignored if the value is false.</param>
        /// <param name="excludeSubTasks">Only return tasks that are not a subtask of another task.</param>
        /// <param name="active">If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned.</param>
        /// <param name="includeTaskLocalVariables">Indication to include task local variables in the result.</param>
        /// <param name="includeProcessVariables">Indication to include process variables in the result.</param>
        /// <param name="scopeDefinitionId">Only return tasks with the given scopeDefinitionId.</param>
        /// <param name="scopeId">Only return tasks with the given scopeId.</param>
        /// <param name="scopeType">Only return tasks with the given scopeType.</param>
        /// <param name="tenantId">Only return tasks with the given tenantId.</param>
        /// <param name="tenantIdLike">Only return tasks with a tenantId like the given value.</param>
        /// <param name="withoutTenantId">If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored.</param>
        /// <param name="candidateOrAssigned">Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups).</param>
        /// <param name="category">Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).</param>
        /// <returns>Indicates request was successful and the tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DataResponseTaskResponse> ListTasksAsync(string name, string nameLike, string description, string priority, string minimumPriority, string maximumPriority, string assignee, string assigneeLike, string owner, string ownerLike, string unassigned, string delegationState, string candidateUser, string candidateGroup, string candidateGroups, string involvedUser, string taskDefinitionKey, string taskDefinitionKeyLike, string taskDefinitionKeys, string processInstanceId, string processInstanceIdWithChildren, string processInstanceBusinessKey, string processInstanceBusinessKeyLike, string processDefinitionId, string processDefinitionKey, string processDefinitionKeyLike, string processDefinitionName, string processDefinitionNameLike, string executionId, System.DateTimeOffset? createdOn, System.DateTimeOffset? createdBefore, System.DateTimeOffset? createdAfter, System.DateTimeOffset? dueOn, System.DateTimeOffset? dueBefore, System.DateTimeOffset? dueAfter, bool? withoutDueDate, bool? excludeSubTasks, bool? active, bool? includeTaskLocalVariables, bool? includeProcessVariables, string scopeDefinitionId, string scopeId, string scopeType, string tenantId, string tenantIdLike, bool? withoutTenantId, string candidateOrAssigned, string category, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks?");
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (description != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("description") + "=").Append(System.Uri.EscapeDataString(ConvertToString(description, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (priority != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("priority") + "=").Append(System.Uri.EscapeDataString(ConvertToString(priority, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (minimumPriority != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("minimumPriority") + "=").Append(System.Uri.EscapeDataString(ConvertToString(minimumPriority, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maximumPriority != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maximumPriority") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maximumPriority, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (assignee != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("assignee") + "=").Append(System.Uri.EscapeDataString(ConvertToString(assignee, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (assigneeLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("assigneeLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(assigneeLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (owner != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("owner") + "=").Append(System.Uri.EscapeDataString(ConvertToString(owner, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (ownerLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("ownerLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(ownerLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (unassigned != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("unassigned") + "=").Append(System.Uri.EscapeDataString(ConvertToString(unassigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (delegationState != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("delegationState") + "=").Append(System.Uri.EscapeDataString(ConvertToString(delegationState, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (candidateUser != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("candidateUser") + "=").Append(System.Uri.EscapeDataString(ConvertToString(candidateUser, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (candidateGroup != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("candidateGroup") + "=").Append(System.Uri.EscapeDataString(ConvertToString(candidateGroup, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (candidateGroups != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("candidateGroups") + "=").Append(System.Uri.EscapeDataString(ConvertToString(candidateGroups, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (involvedUser != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("involvedUser") + "=").Append(System.Uri.EscapeDataString(ConvertToString(involvedUser, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDefinitionKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDefinitionKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDefinitionKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (taskDefinitionKeys != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("taskDefinitionKeys") + "=").Append(System.Uri.EscapeDataString(ConvertToString(taskDefinitionKeys, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceIdWithChildren != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceIdWithChildren") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceIdWithChildren, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceBusinessKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceBusinessKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceBusinessKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processInstanceBusinessKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processInstanceBusinessKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processInstanceBusinessKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKey != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionKeyLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionKeyLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionKeyLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (processDefinitionNameLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("processDefinitionNameLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(processDefinitionNameLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (executionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("executionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(executionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createdOn != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createdOn") + "=").Append(System.Uri.EscapeDataString(createdOn.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createdBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createdBefore") + "=").Append(System.Uri.EscapeDataString(createdBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (createdAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("createdAfter") + "=").Append(System.Uri.EscapeDataString(createdAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueOn != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueOn") + "=").Append(System.Uri.EscapeDataString(dueOn.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueBefore != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueBefore") + "=").Append(System.Uri.EscapeDataString(dueBefore.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dueAfter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("dueAfter") + "=").Append(System.Uri.EscapeDataString(dueAfter.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutDueDate != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutDueDate") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutDueDate, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (excludeSubTasks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("excludeSubTasks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(excludeSubTasks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (active != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("active") + "=").Append(System.Uri.EscapeDataString(ConvertToString(active, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeTaskLocalVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeTaskLocalVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeTaskLocalVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeProcessVariables != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeProcessVariables") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeProcessVariables, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeDefinitionId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeDefinitionId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeDefinitionId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (scopeType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scopeType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scopeType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (tenantIdLike != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("tenantIdLike") + "=").Append(System.Uri.EscapeDataString(ConvertToString(tenantIdLike, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (withoutTenantId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("withoutTenantId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(withoutTenantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (candidateOrAssigned != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("candidateOrAssigned") + "=").Append(System.Uri.EscapeDataString(ConvertToString(candidateOrAssigned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (category != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("category") + "=").Append(System.Uri.EscapeDataString(ConvertToString(category, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataResponseTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format or that delegationState has an invalid value (other than pending and resolved). The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create Task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TaskResponse> CreateTaskAsync(TaskRequest body)
        {
            return CreateTaskAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create Task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TaskResponse> CreateTaskAsync(TaskRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates request was successful and the tasks are returned", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates a parameter was passed in the wrong format or that delegationState has an invalid value (other than pending and resolved). The status-message contains additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a task</summary>
        /// <returns>Indicates the task was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TaskResponse> GetTaskAsync(string taskId)
        {
            return GetTaskAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a task</summary>
        /// <returns>Indicates the task was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TaskResponse> GetTaskAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Tasks actions</summary>
        /// <returns>Indicates the action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ExecuteTaskActionAsync(string taskId, TaskActionRequest body)
        {
            return ExecuteTaskActionAsync(taskId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Tasks actions</summary>
        /// <returns>Indicates the action was executed.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ExecuteTaskActionAsync(string taskId, TaskActionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("When the body contains an invalid value or when the assignee is missing when the action requires it.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the action cannot be performed due to a conflict. Either the task was updates simultaneously or the task was claimed by another user, in case of the claim action.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update a task</summary>
        /// <returns>Indicates the task was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TaskResponse> UpdateTaskAsync(string taskId, TaskRequest body)
        {
            return UpdateTaskAsync(taskId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a task</summary>
        /// <returns>Indicates the task was updated.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TaskResponse> UpdateTaskAsync(string taskId, TaskRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was updated simultaneously.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a task</summary>
        /// <param name="cascadeHistory">Whether or not to delete the HistoricTask instance when deleting the task (if applicable). If not provided, this value defaults to false.</param>
        /// <param name="deleteReason">Reason why the task is deleted. This value is ignored when cascadeHistory is true.</param>
        /// <returns>Indicates the task was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTaskAsync(string taskId, string cascadeHistory, string deleteReason)
        {
            return DeleteTaskAsync(taskId, cascadeHistory, deleteReason, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a task</summary>
        /// <param name="cascadeHistory">Whether or not to delete the HistoricTask instance when deleting the task (if applicable). If not provided, this value defaults to false.</param>
        /// <param name="deleteReason">Reason why the task is deleted. This value is ignored when cascadeHistory is true.</param>
        /// <returns>Indicates the task was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTaskAsync(string taskId, string cascadeHistory, string deleteReason, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}?");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            if (cascadeHistory != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("cascadeHistory") + "=").Append(System.Uri.EscapeDataString(ConvertToString(cascadeHistory, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteReason != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteReason") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteReason, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task cannot be deleted because it\u2019s part of a workflow.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List attachments on a task</summary>
        /// <returns>Indicates the task was found and the attachments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AttachmentResponse>> ListTaskAttachmentsAsync(string taskId)
        {
            return ListTaskAttachmentsAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List attachments on a task</summary>
        /// <returns>Indicates the task was found and the attachments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AttachmentResponse>> ListTaskAttachmentsAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/attachments");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<AttachmentResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a new attachment on a task, containing a link to an external resource or an attached file</summary>
        /// <param name="body">create an attachment containing a link to an external resource</param>
        /// <param name="file">Attachment file</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="description">Description of the attachment, optional</param>
        /// <param name="type">Type of attachment, optional. Supports any arbitrary string or a valid HTTP content-type.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AttachmentResponse> CreateAttachmentAsync(string taskId, TaskAttachmentCollectionResource body, FileParameter file, string name, string description, string type)
        {
            return CreateAttachmentAsync(taskId, body, file, name, description, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new attachment on a task, containing a link to an external resource or an attached file</summary>
        /// <param name="body">create an attachment containing a link to an external resource</param>
        /// <param name="file">Attachment file</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="description">Description of the attachment, optional</param>
        /// <param name="type">Type of attachment, optional. Supports any arbitrary string or a valid HTTP content-type.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AttachmentResponse> CreateAttachmentAsync(string taskId, TaskAttachmentCollectionResource body, FileParameter file, string name, string description, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/attachments");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AttachmentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the attachment was created and the result is returned.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the attachment name is missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AttachmentResponse> GetAttachmentAsync(string taskId, string attachmentId)
        {
            return GetAttachmentAsync(taskId, attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AttachmentResponse> GetAttachmentAsync(string taskId, string attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/attachments/{attachmentId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attachmentId}", System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AttachmentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the tasks does not have a attachment with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteAttachmentAsync(string taskId, string attachmentId)
        {
            return DeleteAttachmentAsync(taskId, attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete an attachment on a task</summary>
        /// <returns>Indicates the task and attachment were found and the attachment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteAttachmentAsync(string taskId, string attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/attachments/{attachmentId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attachmentId}", System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the tasks does not have a attachment with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the content for an attachment</summary>
        /// <returns>Indicates the task and attachment was found and the requested content is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetAttachmentContentAsync(string taskId, string attachmentId)
        {
            return GetAttachmentContentAsync(taskId, attachmentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the content for an attachment</summary>
        /// <returns>Indicates the task and attachment was found and the requested content is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetAttachmentContentAsync(string taskId, string attachmentId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (attachmentId == null)
                throw new System.ArgumentNullException("attachmentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/attachments/{attachmentId}/content");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attachmentId}", System.Uri.EscapeDataString(ConvertToString(attachmentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have an attachment with the given id or the attachment does not have a binary stream available. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List comments on a task</summary>
        /// <returns>Indicates the task was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListTaskCommentsAsync(string taskId)
        {
            return ListTaskCommentsAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List comments on a task</summary>
        /// <returns>Indicates the task was found and the comments are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CommentResponse>> ListTaskCommentsAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/comments");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CommentResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create a new comment on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentResponse> CreateTaskCommentsAsync(string taskId, CommentRequest body)
        {
            return CreateTaskCommentsAsync(taskId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new comment on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentResponse> CreateTaskCommentsAsync(string taskId, CommentRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/comments");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the comment was created and the result is returned.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the comment is missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentResponse> GetTaskCommentAsync(string taskId, string commentId)
        {
            return GetTaskCommentAsync(taskId, commentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentResponse> GetTaskCommentAsync(string taskId, string commentId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (commentId == null)
                throw new System.ArgumentNullException("commentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/comments/{commentId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{commentId}", System.Uri.EscapeDataString(ConvertToString(commentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the tasks does not have a comment with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTaskCommentAsync(string taskId, string commentId)
        {
            return DeleteTaskCommentAsync(taskId, commentId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a comment on a task</summary>
        /// <returns>Indicates the task and comment were found and the comment is deleted. Response body is left empty intentionally.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTaskCommentAsync(string taskId, string commentId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (commentId == null)
                throw new System.ArgumentNullException("commentId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/comments/{commentId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{commentId}", System.Uri.EscapeDataString(ConvertToString(commentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the tasks does not have a comment with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List events for a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<EventResponse>> ListTaskEventsAsync(string taskId)
        {
            return ListTaskEventsAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List events for a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<EventResponse>> ListTaskEventsAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/events");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<EventResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get an event on a task</summary>
        /// <returns>Indicates the task and event were found and the event is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<EventResponse> GetEventAsync(string taskId, string eventId)
        {
            return GetEventAsync(taskId, eventId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get an event on a task</summary>
        /// <returns>Indicates the task and event were found and the event is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<EventResponse> GetEventAsync(string taskId, string eventId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (eventId == null)
                throw new System.ArgumentNullException("eventId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/events/{eventId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{eventId}", System.Uri.EscapeDataString(ConvertToString(eventId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the tasks does not have an event with the given ID.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete an event on a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteEventAsync(string taskId, string eventId)
        {
            return DeleteEventAsync(taskId, eventId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete an event on a task</summary>
        /// <returns>Indicates the task was found and the events are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteEventAsync(string taskId, string eventId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (eventId == null)
                throw new System.ArgumentNullException("eventId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/events/{eventId}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{eventId}", System.Uri.EscapeDataString(ConvertToString(eventId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have the requested event.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a task form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> GetTaskFormAsync(string taskId)
        {
            return GetTaskFormAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a task form</summary>
        /// <returns>Indicates request was successful and the task form is returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> GetTaskFormAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/form");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List identity links for a task</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListTasksInstanceIdentityLinksAsync(string taskId)
        {
            return ListTasksInstanceIdentityLinksAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links for a task</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListTasksInstanceIdentityLinksAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/identitylinks");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestIdentityLink>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create an identity link on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestIdentityLink> CreateTaskInstanceIdentityLinksAsync(string taskId, RestIdentityLink body)
        {
            return CreateTaskInstanceIdentityLinksAsync(taskId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create an identity link on a task</summary>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestIdentityLink> CreateTaskInstanceIdentityLinksAsync(string taskId, RestIdentityLink body, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/identitylinks");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestIdentityLink>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the task was found and the identity link was created.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have the requested identityLink. The status contains additional information about this error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List identity links for a task for either groups or users</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListIdentityLinksForFamilyAsync(string taskId, string family)
        {
            return ListIdentityLinksForFamilyAsync(taskId, family, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List identity links for a task for either groups or users</summary>
        /// <returns>Indicates the task was found and the requested identity links are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestIdentityLink>> ListIdentityLinksForFamilyAsync(string taskId, string family, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (family == null)
                throw new System.ArgumentNullException("family");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/identitylinks/{family}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{family}", System.Uri.EscapeDataString(ConvertToString(family, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestIdentityLink>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a single identity link on a task</summary>
        /// <returns>Indicates the task and identity link was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestIdentityLink> GetTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type)
        {
            return GetTaskInstanceIdentityLinksAsync(taskId, family, identityId, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a single identity link on a task</summary>
        /// <returns>Indicates the task and identity link was found and returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestIdentityLink> GetTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (family == null)
                throw new System.ArgumentNullException("family");

            if (identityId == null)
                throw new System.ArgumentNullException("identityId");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/identitylinks/{family}/{identityId}/{type}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{family}", System.Uri.EscapeDataString(ConvertToString(family, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{identityId}", System.Uri.EscapeDataString(ConvertToString(identityId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{type}", System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestIdentityLink>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have the requested identityLink. The status contains additional information about this error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete an identity link on a task</summary>
        /// <returns>Indicates the task and identity link were found and the link has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type)
        {
            return DeleteTaskInstanceIdentityLinksAsync(taskId, family, identityId, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete an identity link on a task</summary>
        /// <returns>Indicates the task and identity link were found and the link has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTaskInstanceIdentityLinksAsync(string taskId, string family, string identityId, string type, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (family == null)
                throw new System.ArgumentNullException("family");

            if (identityId == null)
                throw new System.ArgumentNullException("identityId");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/identitylinks/{family}/{identityId}/{type}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{family}", System.Uri.EscapeDataString(ConvertToString(family, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{identityId}", System.Uri.EscapeDataString(ConvertToString(identityId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{type}", System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have the requested identityLink. The status contains additional information about this error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List of sub tasks for a task</summary>
        /// <returns>Indicates request was successful and the  sub tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TaskResponse>> ListTaskSubtasksAsync(string taskId)
        {
            return ListTaskSubtasksAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List of sub tasks for a task</summary>
        /// <returns>Indicates request was successful and the  sub tasks are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TaskResponse>> ListTaskSubtasksAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/subtasks");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<TaskResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>List variables for a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListTaskVariablesAsync(string taskId, string scope)
        {
            return ListTaskVariablesAsync(taskId, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List variables for a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RestVariable>> ListTaskVariablesAsync(string taskId, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables?");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<RestVariable>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found..", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Create new variables on a task</summary>
        /// <param name="body">Create a variable on a task</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is created. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable that is created. If omitted, local is assumed.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CreateTaskVariableAsync(string taskId, TaskVariableCollectionResource body, string name, string type, string scope)
        {
            return CreateTaskVariableAsync(taskId, body, name, type, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create new variables on a task</summary>
        /// <param name="body">Create a variable on a task</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is created. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable that is created. If omitted, local is assumed.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CreateTaskVariableAsync(string taskId, TaskVariableCollectionResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the variables were created and the result is returned.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the name of a variable to create was missing or that an attempt is done to create a variable on a standalone task (without a process associated) with scope global or an empty array of variables was included in the request or request did not contain an array of variables. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the task already has a variable with the given name. Use the PUT method to update the task variable instead.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 415)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the serializable data contains an object for which no class is present in the JVM running the Flowable engine and therefore cannot be deserialized.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete all local variables on a task</summary>
        /// <returns>Indicates all local task variables have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteAllLocalTaskVariablesAsync(string taskId)
        {
            return DeleteAllLocalTaskVariablesAsync(taskId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all local variables on a task</summary>
        /// <returns>Indicates all local task variables have been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteAllLocalTaskVariablesAsync(string taskId, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get a variable from a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestVariable> GetTaskInstanceVariableAsync(string taskId, string variableName, string scope)
        {
            return GetTaskInstanceVariableAsync(taskId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a variable from a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestVariable> GetTaskInstanceVariableAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables/{variableName}?");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestVariable>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have a variable with the given name (in the given scope). Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Update an existing variable on a task</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>Indicates the variables was updated and the result is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestVariable> UpdateTaskInstanceVariableAsync(string taskId, string variableName, TaskVariableResource body, string name, string type, string scope)
        {
            return UpdateTaskInstanceVariableAsync(taskId, variableName, body, name, type, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update an existing variable on a task</summary>
        /// <param name="body">Update a task variable</param>
        /// <param name="name">Required name of the variable</param>
        /// <param name="type">Type of variable that is updated. If omitted, reverts to raw JSON-value type (string, boolean, integer or double)</param>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable..</param>
        /// <returns>Indicates the variables was updated and the result is returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestVariable> UpdateTaskInstanceVariableAsync(string taskId, string variableName, TaskVariableResource body, string name, string type, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables/{variableName}");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestVariable>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the name of a variable to update was missing or that an attempt is done to update a variable on a standalone task (without a process associated) with scope global. Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have a variable with the given name in the given scope. Status message contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 415)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the serializable data contains an object for which no class is present in the JVM running the Flowable engine and therefore cannot be deserialized.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Delete a variable on a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTaskInstanceVariableAsync(string taskId, string variableName, string scope)
        {
            return DeleteTaskInstanceVariableAsync(taskId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a variable on a task</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task variable was found and has been deleted. Response-body is intentionally empty.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTaskInstanceVariableAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables/{variableName}?");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have a variable with the given name. Status message contains additional information about the error.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>Get the binary data for a variable</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetTaskVariableDataAsync(string taskId, string variableName, string scope)
        {
            return GetTaskVariableDataAsync(taskId, variableName, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get the binary data for a variable</summary>
        /// <param name="scope">Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task’s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable.</param>
        /// <returns>Indicates the task was found and the requested variables are returned.</returns>
        /// <exception cref="FlowableHttpClientException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> GetTaskVariableDataAsync(string taskId, string variableName, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (taskId == null)
                throw new System.ArgumentNullException("taskId");

            if (variableName == null)
                throw new System.ArgumentNullException("variableName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("runtime/tasks/{taskId}/variables/{variableName}/data?");
            urlBuilder_.Replace("{taskId}", System.Uri.EscapeDataString(ConvertToString(taskId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{variableName}", System.Uri.EscapeDataString(ConvertToString(variableName, System.Globalization.CultureInfo.InvariantCulture)));
            if (scope != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("scope") + "=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new FlowableHttpClientException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("Indicates the requested task was not found or the task does not have a variable with the given name (in the given scope). Status message provides additional information.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new FlowableHttpClientException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new FlowableHttpClientException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new FlowableHttpClientException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
